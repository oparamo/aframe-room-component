/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (() => {

eval("\n\nAFRAME.registerSystem('building', {\n\n  reexamineBuilding: function () {\n    // console.log(\" = REEVALUATION REQUESTED...\");\n\n    const buildingSelf = this;\n    const HAIR = 0.0001;\n\n    /*\n\n    https://github.com/oparamo/aframe-room-component\n    v0.5.0\n\n    OPTIMIZATION:\n\n    currently, the entire building is getting re-generated from scratch any time anything in it changes.\n    obviously this is wasteful, but:\n    - this library isn't particularly likely to be used in a context where these properties will be changing at runtime (at least outside of debugging)\n    - right now I am more concerned with getting it out the door than making it perfect anyway\n\n    PLANNED FEATURES TO COME (in order):\n    - greater control over UV generation\n    - automatic collision assignment\n    - doors lifted above the ground (i.e. windows)\n    - accept a shape to be extruded around a doorhole to make a doorframe (& around a floor to make a baseboard)\n\n    KNOWN ISSUES (with no obvious solution that would preserve ease of use):\n    - floor/ceiling triangulation is not controllable (and therefore varying wall verticality is nearly useless unless slope is consistent)\n    - doorhole parenting is always level to the horizon even on slope-floored walls\n    - the setTimeout thing results in a one-frame flash of invisible walls: is it worth it? (is there a smarter thing to listen for, maybe?)\n\n    ISSUES THAT COULD THEORETICALLY BE FIXED BUT DON'T SEEM WORTH THE TROUBLE:\n    - walls are internally rearranged to always wind CW, which means wall parenting will point towards the \"previous\" wall if you entered them in CCW order\n\n    */\n\n    function flipGeom (geom) {\n      const indexCopy = geom.index;\n      for (let curFaceIndex = 0; curFaceIndex < indexCopy.count / 3; curFaceIndex++) {\n        const bucket = indexCopy[curFaceIndex * 3 + 2];\n        indexCopy[curFaceIndex * 3 + 2] = indexCopy[curFaceIndex * 3 + 1];\n        indexCopy[curFaceIndex * 3 + 1] = bucket;\n      }\n      geom.setIndex(indexCopy);\n    }\n\n    function makeUvsForGeom (geom, callback) {\n      const allUVs = [];\n      for (let faceVertIndex = 0; faceVertIndex < geom.index.array.length; faceVertIndex++) {\n        const vertexIndex = geom.index.array[faceVertIndex];\n        const vertex = new THREE.Vector3(\n          geom.attributes.position.getX(vertexIndex),\n          geom.attributes.position.getY(vertexIndex),\n          geom.attributes.position.getZ(vertexIndex)\n        );\n        const uv = callback(vertex, faceVertIndex % 3);\n        allUVs[vertexIndex * 2 + 0] = uv[0];\n        allUVs[vertexIndex * 2 + 1] = uv[1];\n      }\n      geom.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(allUVs), 2));\n      geom.uvsNeedUpdate = true;\n    }\n    function makePlaneUvs (geom, uKey, vKey, uMult, vMult) {\n      makeUvsForGeom(geom, (pt) => {\n        return [\n          pt[uKey] * uMult,\n          pt[vKey] * vMult\n        ];\n      });\n    }\n\n    function finishGeom (geom) {\n      geom.computeVertexNormals();\n      // are these necessary?\n      geom.computeBoundingBox();\n      geom.computeBoundingSphere();\n    }\n\n    function getUnsortedRoomWallArray (roomEl) {\n      const walls = [];\n      for (let roomChildNodeIndex = 0; roomChildNodeIndex < roomEl.children.length; roomChildNodeIndex++) {\n        const roomChildNode = roomEl.children[roomChildNodeIndex];\n        if (roomChildNode.components.wall) { walls.push(roomChildNode); }\n      }\n      return walls;\n    }\n\n    function getRoomWallArray (roomEl) {\n      // the results of this not being saved anywhere is super wasteful,\n      // but, see above; not worth worrying about yet\n\n      const isOutside = roomEl.components.room.data.outside;\n\n      const walls = getUnsortedRoomWallArray(roomEl);\n\n      let cwSum = 0;\n      for (let wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n        const curWallNode = walls[wallIndex];\n        const nextWallNode = walls[(wallIndex + 1) % walls.length];\n        const curWallPos = curWallNode.components.position.data;\n        const nextWallPos = nextWallNode.components.position.data;\n\n        cwSum += (nextWallPos.x - curWallPos.x) * (nextWallPos.z + curWallPos.z);\n      }\n\n      let shouldReverse = false;\n      if (cwSum > 0) { shouldReverse = !shouldReverse; }\n      if (isOutside) { shouldReverse = !shouldReverse; }\n      if (shouldReverse) { walls.reverse(); }\n\n      return walls;\n    }\n    function getNextWallEl (wallEl) {\n      const wallList = getRoomWallArray(wallEl.parentNode);\n      const curWallIndex = wallList.indexOf(wallEl);\n      return wallList[(curWallIndex + 1) % wallList.length];\n    }\n\n    const worldWallPos = new THREE.Vector3();\n    const worldNextPos = new THREE.Vector3();\n    const worldLinkPos = new THREE.Vector3();\n    function moveForLink (doorholeEl, doorlinkEl) {\n      const holeWallEl = doorholeEl.parentNode;\n      const nextWallEl = getNextWallEl(holeWallEl);\n      if (!nextWallEl) { return; }\n\n      holeWallEl.object3D.getWorldPosition(worldWallPos);\n      nextWallEl.object3D.getWorldPosition(worldNextPos);\n      doorlinkEl.object3D.getWorldPosition(worldLinkPos);\n\n      const linkGapX = worldLinkPos.x - worldWallPos.x;\n      const linkGapZ = worldLinkPos.z - worldWallPos.z;\n\n      const wallGapX = worldNextPos.x - worldWallPos.x;\n      const wallGapZ = worldNextPos.z - worldWallPos.z;\n      const wallAng = Math.atan2(wallGapZ, wallGapX);\n      const wallLength = Math.sqrt(wallGapX * wallGapX + wallGapZ * wallGapZ);\n\n      let localLinkX = linkGapX * Math.cos(-wallAng) - linkGapZ * Math.sin(-wallAng);\n      // var localLinkZ = linkGapX*Math.sin(-wallAng) + linkGapZ*Math.cos(-wallAng);\n\n      const doorHalf = doorlinkEl.components.doorlink.data.width / 2;\n      localLinkX = Math.max(localLinkX, doorHalf + HAIR);\n      localLinkX = Math.min(localLinkX, wallLength - doorHalf - HAIR);\n\n      doorholeEl.setAttribute('position', { x: localLinkX, y: 0, z: 0 });\n      doorholeEl.object3D.updateMatrixWorld();\n    }\n\n    function getHoleLink (doorholeEl) {\n      const doorlinks = buildingSelf.el.querySelectorAll('[doorlink]');\n      for (let curLinkIndex = 0; curLinkIndex < doorlinks.length; curLinkIndex++) {\n        const curLink = doorlinks[curLinkIndex];\n        if (curLink.components.doorlink.data.from == doorholeEl) { return curLink; }\n        if (curLink.components.doorlink.data.to == doorholeEl) { return curLink; }\n      }\n    }\n\n    function getWallHeight (wallEl) {\n      if (wallEl.components.wall.data.height) { return wallEl.components.wall.data.height; }\n      return wallEl.parentNode.components.room.data.height;\n    }\n\n    if (buildingSelf.dirty) { return; }\n    buildingSelf.dirty = true;\n    setTimeout(() => {\n      // console.log(\" == STARTING RE-EVALUATION...\");\n\n      // silly but necessary because of threeJS weirdness\n      buildingSelf.el.object3D.updateMatrixWorld();\n\n      // lay out walls' angles:\n\n      for (var sceneChildNodeIndex = 0; sceneChildNodeIndex < buildingSelf.el.children.length; sceneChildNodeIndex++) {\n        var sceneChildNode = buildingSelf.el.children[sceneChildNodeIndex];\n        if (sceneChildNode.components && sceneChildNode.components.room) {\n          const w = sceneChildNode.components.room.data.width;\n          const l = sceneChildNode.components.room.data.length;\n          if (w || l) {\n            if (w && l) {\n              const rawWalls = getUnsortedRoomWallArray(sceneChildNode);\n              if (rawWalls.length >= 4) {\n                if (rawWalls.length > 4) { console.error('rooms with WIDTH and LENGTH should only have four walls!'); }\n                rawWalls[0].setAttribute('position', { x: 0, y: 0, z: 0 });\n                rawWalls[1].setAttribute('position', { x: w, y: 0, z: 0 });\n                rawWalls[2].setAttribute('position', { x: w, y: 0, z: l });\n                rawWalls[3].setAttribute('position', { x: 0, y: 0, z: l });\n              } else {\n                console.error('rooms with WIDTH and LENGTH must have four walls!');\n              }\n            } else {\n              console.error('rooms with WIDTH must also have LENGTH (and vice versa)');\n            }\n          }\n\n          var walls = getRoomWallArray(sceneChildNode);\n          if (walls.length > 2) {\n            for (var wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n              var curWallNode = walls[wallIndex];\n              var nextWallNode = walls[(wallIndex + 1) % walls.length];\n\n              var wallGapX = nextWallNode.components.position.data.x - curWallNode.components.position.data.x;\n              var wallGapZ = nextWallNode.components.position.data.z - curWallNode.components.position.data.z;\n              var wallAng = Math.atan2(wallGapZ, wallGapX);\n\n              curWallNode.setAttribute('rotation', { x: 0, y: -wallAng / Math.PI * 180, z: 0 });\n              curWallNode.object3D.updateMatrixWorld();\n            }\n          }\n        }\n      }\n\n      // position the door holes:\n\n      const doorlinks = buildingSelf.el.querySelectorAll('[doorlink]');\n      for (var curDoorlinkElIndex = 0; curDoorlinkElIndex < doorlinks.length; curDoorlinkElIndex++) {\n        var curDoorlinkEl = doorlinks[curDoorlinkElIndex];\n        var curDoorlink = curDoorlinkEl.components.doorlink;\n        if (!curDoorlink) { return; }// still setting up, try again later\n\n        moveForLink(curDoorlink.data.from, curDoorlink.el);\n        moveForLink(curDoorlink.data.to, curDoorlink.el);\n      }\n\n      // generate the walls' geometry:\n\n      for (var sceneChildNodeIndex = 0; sceneChildNodeIndex < buildingSelf.el.children.length; sceneChildNodeIndex++) {\n        var sceneChildNode = buildingSelf.el.children[sceneChildNodeIndex];\n        if (sceneChildNode.components && sceneChildNode.components.room) {\n          const isOutside = sceneChildNode.components.room.data.outside;\n          var walls = getRoomWallArray(sceneChildNode);\n\n          if (walls.length > 2) {\n            for (var wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n              var curWallNode = walls[wallIndex];\n              var nextWallNode = walls[(wallIndex + 1) % walls.length];\n\n              var wallGapX = nextWallNode.components.position.data.x - curWallNode.components.position.data.x;\n              var wallGapZ = nextWallNode.components.position.data.z - curWallNode.components.position.data.z;\n              const wallLength = Math.sqrt(wallGapX * wallGapX + wallGapZ * wallGapZ);\n              var wallAng = Math.atan2(wallGapZ, wallGapX);\n\n              const wallGapY = nextWallNode.components.position.data.y - curWallNode.components.position.data.y;\n              const heightGap = getWallHeight(nextWallNode) - getWallHeight(curWallNode);\n\n              const orderedHoles = [];\n              for (let wallChildNodeIndex = 0; wallChildNodeIndex < curWallNode.children.length; wallChildNodeIndex++) {\n                const wallChildNode = curWallNode.children[wallChildNodeIndex];\n                if (wallChildNode.components && wallChildNode.components.doorhole) {\n                  orderedHoles.push(wallChildNode);\n                }\n              }\n              orderedHoles.sort((a, b) => {\n                return a.components.position.data.x - b.components.position.data.x;\n              });\n\n              const wallShape = new THREE.Shape();\n              wallShape.moveTo(\n                0,\n                getWallHeight(curWallNode)\n              );\n              wallShape.lineTo(\n                0,\n                0\n              );\n\n              for (let holeIndex = 0; holeIndex < orderedHoles.length; holeIndex++) {\n                var holeEl = orderedHoles[holeIndex];\n                if (!holeEl.myVerts) { holeEl.myVerts = []; }\n                holeEl.myVerts.length = 0;\n\n                const linkEl = getHoleLink(orderedHoles[holeIndex]);\n                if (!linkEl) { continue; }\n\n                const holeInfo = holeEl.components;\n                const linkInfo = linkEl.components;\n\n                for (let holeSide = -1; holeSide <= 1; holeSide += 2) {\n                  var ptX = holeInfo.position.data.x + linkInfo.doorlink.data.width / 2 * holeSide;\n                  const floorY = (ptX / wallLength) * wallGapY;\n                  let topY = floorY + linkInfo.doorlink.data.height;\n\n                  const curCeil = getWallHeight(curWallNode) + (ptX / wallLength) * heightGap;\n                  const maxTopY = floorY + curCeil - HAIR;// will always be a seam, but, I'm not bothering to rewrite just for that\n                  if (topY > maxTopY) { topY = maxTopY; }\n\n                  function addWorldVert (ptY) {\n                    const tempPos = new THREE.Vector3(ptX, ptY, 0);\n                    curWallNode.object3D.localToWorld(tempPos);\n                    holeEl.myVerts.push(tempPos);\n                  }\n                  addWorldVert(floorY);\n                  addWorldVert(topY);\n\n                  if (holeSide < 0) {\n                    wallShape.lineTo(ptX, floorY);\n                    wallShape.lineTo(ptX, topY);\n                  } else {\n                    wallShape.lineTo(ptX, topY);\n                    wallShape.lineTo(ptX, floorY);\n                  }\n                }\n              }\n\n              wallShape.lineTo(\n                wallLength,\n                nextWallNode.components.position.data.y - curWallNode.components.position.data.y\n              );\n              wallShape.lineTo(\n                wallLength,\n                (nextWallNode.components.position.data.y - curWallNode.components.position.data.y) + getWallHeight(nextWallNode)\n              );\n\n              const wallGeom = new THREE.ShapeGeometry(wallShape);\n              makePlaneUvs(wallGeom, 'x', 'y', 1, 1);\n              finishGeom(wallGeom);\n              var myMat = curWallNode.components.material ? curWallNode.components.material.material : curWallNode.parentNode.components.material.material;\n              if (curWallNode.myMesh) {\n                curWallNode.myMesh.geometry = wallGeom;\n                curWallNode.myMesh.material = myMat;\n              } else {\n                curWallNode.myMesh = new THREE.Mesh(wallGeom, myMat);\n                curWallNode.setObject3D('wallMesh', curWallNode.myMesh);\n              }\n            }\n\n            const caps = [];\n            for (let roomChildNodeIndex = 0; roomChildNodeIndex < sceneChildNode.children.length; roomChildNodeIndex++) {\n              const roomChildNode = sceneChildNode.children[roomChildNodeIndex];\n              if (roomChildNode.components) {\n                if (roomChildNode.components.floor || roomChildNode.components.ceiling) { caps.push(roomChildNode); }\n              }\n            }\n            for (let curCapNodeIndex = 0; curCapNodeIndex < caps.length; curCapNodeIndex++) {\n              const curCapNode = caps[curCapNodeIndex];\n              const isCeiling = curCapNode.components.ceiling;\n\n              const capShape = new THREE.Shape();\n              for (var wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n                var curWallNode = walls[wallIndex];\n                var ptX = curWallNode.components.position.data.x;\n                const ptZ = curWallNode.components.position.data.z;\n                if (wallIndex) {\n                  capShape.lineTo(ptX, ptZ);\n                } else {\n                  capShape.moveTo(ptX, ptZ);\n                }\n              }\n              const capGeom = new THREE.ShapeGeometry(capShape);\n              for (var wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n                var curWallNode = walls[wallIndex];\n                const curVert = new THREE.Vector3(\n                  capGeom.attributes.position.getX(wallIndex),\n                  capGeom.attributes.position.getY(wallIndex),\n                  capGeom.attributes.position.getZ(wallIndex)\n                );\n                curVert.set(curVert.x, curWallNode.components.position.data.y, curVert.y);\n                if (isCeiling) { curVert.y += getWallHeight(curWallNode); }\n                capGeom.attributes.position.setXYZ(wallIndex, curVert.x, curVert.y, curVert.z);\n              }\n\n              let shouldReverse = false;\n              if (!isCeiling) { shouldReverse = !shouldReverse; }\n              if (isOutside) { shouldReverse = !shouldReverse; }\n              if (shouldReverse) { flipGeom(capGeom); }\n\n              makePlaneUvs(capGeom, 'x', 'z', isCeiling ? 1 : -1, 1);\n              finishGeom(capGeom);\n\n              if (!curCapNode.myMeshes) { curCapNode.myMeshes = []; }\n\n              const typeLabel = isCeiling ? 'ceiling' : 'floor';\n              var myMat = curCapNode.components.material ? curCapNode.components.material.material : curCapNode.parentNode.components.material.material;\n              if (curCapNode.myMeshes[typeLabel]) {\n                curCapNode.myMeshes[typeLabel].geometry = capGeom;\n                curCapNode.myMeshes[typeLabel].material = myMat;\n              } else {\n                curCapNode.myMeshes[typeLabel] = new THREE.Mesh(capGeom, myMat);\n                curCapNode.setObject3D(typeLabel, curCapNode.myMeshes[typeLabel]);\n              }\n            }\n          }\n        }\n      }\n\n      // generate the door tunnels' geometry:\n\n      for (var curDoorlinkElIndex = 0; curDoorlinkElIndex < doorlinks.length; curDoorlinkElIndex++) {\n        var curDoorlinkEl = doorlinks[curDoorlinkElIndex];\n\n        var curDoorlink = curDoorlinkEl.components.doorlink;\n        if (!curDoorlink.data.from) { continue; }\n        if (!curDoorlink.data.to) { continue; }\n        if (!curDoorlink.data.from.myVerts) { return; }\n        if (!curDoorlink.data.to.myVerts) { return; }\n\n        for (let doorLinkChildIndex = 0; doorLinkChildIndex < curDoorlinkEl.children.length; doorLinkChildIndex++) {\n          var doorLinkChild = curDoorlinkEl.children[doorLinkChildIndex];\n          if (!doorLinkChild.components) { continue; }\n\n          const types = ['sides', 'floor', 'ceiling'];\n          for (let curTypeIndex = 0; curTypeIndex < types.length; curTypeIndex++) {\n            const curType = types[curTypeIndex];\n\n            if (!doorLinkChild.components[curType]) { continue; }\n\n            var myMat = doorLinkChild.components.material ? doorLinkChild.components.material.material : doorLinkChild.parentNode.components.material.material;\n\n            if (!doorLinkChild.myGeoms) { doorLinkChild.myGeoms = []; }\n            if (!doorLinkChild.myGeoms[curType]) {\n              var curGeom = new THREE.BufferGeometry();\n              doorLinkChild.myGeoms[curType] = curGeom;\n              const myMesh = new THREE.Mesh(\n                curGeom,\n                myMat\n              );\n              curGeom.meshRef = myMesh;\n              doorLinkChild.setObject3D(curType, myMesh);\n              const indexArray = [];\n              indexArray.push(0, 1, 2, 1, 3, 2);\n              if (curType == 'sides') { indexArray.push(4, 5, 6, 5, 7, 6); }\n              curGeom.setIndex(indexArray);\n            }\n\n            var curGeom = doorLinkChild.myGeoms[curType];\n            curGeom.meshRef.material = myMat;\n            var positionArray = [];\n            function addWorldVertex (pt) {\n              const localPt = pt.clone();\n              doorLinkChild.object3D.worldToLocal(localPt);\n              positionArray.push(localPt.x, localPt.y, localPt.z);\n            }\n            function commitVertices () {\n              curGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positionArray), 3));\n            }\n            const fVerts = curDoorlink.data.from.myVerts;\n            const tVerts = curDoorlink.data.to.myVerts;\n            switch (curType) {\n              case 'floor':\n\n                addWorldVertex(tVerts[0]);\n                addWorldVertex(tVerts[2]);\n                addWorldVertex(fVerts[2]);\n                addWorldVertex(fVerts[0]);\n\n                commitVertices();\n\n                makeUvsForGeom(curGeom, (pt, vertIndex) => {\n                  return [\n                    1 - (vertIndex % 2),\n                    1 - Math.floor(vertIndex / 2)\n                  ];\n                });\n\n                break;\n              case 'ceiling':\n\n                addWorldVertex(tVerts[3]);\n                addWorldVertex(tVerts[1]);\n                addWorldVertex(fVerts[1]);\n                addWorldVertex(fVerts[3]);\n\n                commitVertices();\n\n                makeUvsForGeom(curGeom, (pt, vertIndex) => {\n                  return [\n                    vertIndex % 2,\n                    1 - Math.floor(vertIndex / 2)\n                  ];\n                });\n\n                break;\n              case 'sides':\n\n                addWorldVertex(tVerts[2]);\n                addWorldVertex(tVerts[3]);\n                addWorldVertex(fVerts[0]);\n                addWorldVertex(fVerts[1]);\n\n                addWorldVertex(fVerts[2]);\n                addWorldVertex(fVerts[3]);\n                addWorldVertex(tVerts[0]);\n                addWorldVertex(tVerts[1]);\n\n                commitVertices();\n\n                makeUvsForGeom(curGeom, (pt, vertIndex) => {\n                  const uv = [];\n                  uv[0] = Math.floor(vertIndex / 2);\n                  uv[1] = vertIndex % 2;\n                  if (vertIndex < 4) { uv[0] = 1 - uv[0]; }\n                  return uv;\n                });\n\n                break;\n            }\n            finishGeom(curGeom);\n          }\n        }\n      }\n\n      // console.log(\" === RE-EVALUATION COMPLETE!\");\n      buildingSelf.dirty = false;\n    });\n  }\n\n});\n\nfunction updateScene (lastScene) {\n  if (lastScene && lastScene.systems.building) { lastScene.systems.building.reexamineBuilding(); }\n}\nfunction positionWatch (e) {\n  if (e.detail.name == 'position') { updateScene(e.detail.target.sceneEl); }\n}\n\nfunction nodeSceneInit () {\n  this.lastScene = this.el.sceneEl;\n  updateScene(this.lastScene);\n  this.el.addEventListener('componentchanged', positionWatch);\n}\nfunction nodeSceneUpdate () {\n  updateScene(this.lastScene);\n}\nfunction nodeSceneRemove () {\n  updateScene(this.lastScene);\n  this.lastScene = null;\n  this.el.removeEventListener('componentchanged', positionWatch);\n}\n\nconst refreshSceneConfig = {\n  init: nodeSceneInit,\n  update: nodeSceneUpdate,\n  remove: nodeSceneRemove\n};\n\nAFRAME.registerComponent('room', Object.assign({\n\n  schema: {\n    outside: { type: 'boolean' },\n    height: { type: 'number', default: 2.4 },\n    width: { type: 'number' },\n    length: { type: 'number' }\n  }\n\n}, refreshSceneConfig));\n\nAFRAME.registerComponent('wall', Object.assign({\n\n  schema: {\n    height: { type: 'number' }\n  }\n\n}, refreshSceneConfig));\n\nAFRAME.registerComponent('floor', refreshSceneConfig);\nAFRAME.registerComponent('ceiling', refreshSceneConfig);\n\nAFRAME.registerComponent('doorhole', refreshSceneConfig);\n\nAFRAME.registerComponent('doorlink', Object.assign({\n\n  schema: {\n    from: { type: 'selector' },\n    to: { type: 'selector' },\n    height: { type: 'number', default: 2.0 },\n    width: { type: 'number', default: 0.8 }\n  }\n\n}, refreshSceneConfig));\n\nAFRAME.registerComponent('sides', refreshSceneConfig);\n\n// could probably automate this rather than hard-coding it, but this'll do for now:\n\nAFRAME.registerPrimitive('rw-room', {\n  defaultComponents: { room: {} },\n  mappings: {\n    outside: 'room.outside',\n    height: 'room.height',\n    width: 'room.width',\n    length: 'room.length'\n  }\n});\n\nAFRAME.registerPrimitive('rw-wall', {\n  defaultComponents: { wall: {} },\n  mappings: {\n    height: 'wall.height'\n  }\n});\n\nAFRAME.registerPrimitive('rw-floor', {\n  defaultComponents: { floor: {} },\n  mappings: {}\n});\n\nAFRAME.registerPrimitive('rw-ceiling', {\n  defaultComponents: { ceiling: {} },\n  mappings: {}\n});\n\nAFRAME.registerPrimitive('rw-doorhole', {\n  defaultComponents: { doorhole: {} },\n  mappings: {}\n});\n\nAFRAME.registerPrimitive('rw-doorlink', {\n  defaultComponents: { doorlink: {} },\n  mappings: {\n    from: 'doorlink.from',\n    to: 'doorlink.to',\n    height: 'doorlink.height',\n    width: 'doorlink.width'\n  }\n});\n\nAFRAME.registerPrimitive('rw-sides', {\n  defaultComponents: { sides: {} },\n  mappings: {}\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFRDtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZnJhbWUtcm9vbS1jb21wb25lbnQvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbkFGUkFNRS5yZWdpc3RlclN5c3RlbSgnYnVpbGRpbmcnLCB7XG5cbiAgcmVleGFtaW5lQnVpbGRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIiA9IFJFRVZBTFVBVElPTiBSRVFVRVNURUQuLi5cIik7XG5cbiAgICBjb25zdCBidWlsZGluZ1NlbGYgPSB0aGlzO1xuICAgIGNvbnN0IEhBSVIgPSAwLjAwMDE7XG5cbiAgICAvKlxuXG4gICAgaHR0cHM6Ly9naXRodWIuY29tL29wYXJhbW8vYWZyYW1lLXJvb20tY29tcG9uZW50XG4gICAgdjAuNS4wXG5cbiAgICBPUFRJTUlaQVRJT046XG5cbiAgICBjdXJyZW50bHksIHRoZSBlbnRpcmUgYnVpbGRpbmcgaXMgZ2V0dGluZyByZS1nZW5lcmF0ZWQgZnJvbSBzY3JhdGNoIGFueSB0aW1lIGFueXRoaW5nIGluIGl0IGNoYW5nZXMuXG4gICAgb2J2aW91c2x5IHRoaXMgaXMgd2FzdGVmdWwsIGJ1dDpcbiAgICAtIHRoaXMgbGlicmFyeSBpc24ndCBwYXJ0aWN1bGFybHkgbGlrZWx5IHRvIGJlIHVzZWQgaW4gYSBjb250ZXh0IHdoZXJlIHRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZSBjaGFuZ2luZyBhdCBydW50aW1lIChhdCBsZWFzdCBvdXRzaWRlIG9mIGRlYnVnZ2luZylcbiAgICAtIHJpZ2h0IG5vdyBJIGFtIG1vcmUgY29uY2VybmVkIHdpdGggZ2V0dGluZyBpdCBvdXQgdGhlIGRvb3IgdGhhbiBtYWtpbmcgaXQgcGVyZmVjdCBhbnl3YXlcblxuICAgIFBMQU5ORUQgRkVBVFVSRVMgVE8gQ09NRSAoaW4gb3JkZXIpOlxuICAgIC0gZ3JlYXRlciBjb250cm9sIG92ZXIgVVYgZ2VuZXJhdGlvblxuICAgIC0gYXV0b21hdGljIGNvbGxpc2lvbiBhc3NpZ25tZW50XG4gICAgLSBkb29ycyBsaWZ0ZWQgYWJvdmUgdGhlIGdyb3VuZCAoaS5lLiB3aW5kb3dzKVxuICAgIC0gYWNjZXB0IGEgc2hhcGUgdG8gYmUgZXh0cnVkZWQgYXJvdW5kIGEgZG9vcmhvbGUgdG8gbWFrZSBhIGRvb3JmcmFtZSAoJiBhcm91bmQgYSBmbG9vciB0byBtYWtlIGEgYmFzZWJvYXJkKVxuXG4gICAgS05PV04gSVNTVUVTICh3aXRoIG5vIG9idmlvdXMgc29sdXRpb24gdGhhdCB3b3VsZCBwcmVzZXJ2ZSBlYXNlIG9mIHVzZSk6XG4gICAgLSBmbG9vci9jZWlsaW5nIHRyaWFuZ3VsYXRpb24gaXMgbm90IGNvbnRyb2xsYWJsZSAoYW5kIHRoZXJlZm9yZSB2YXJ5aW5nIHdhbGwgdmVydGljYWxpdHkgaXMgbmVhcmx5IHVzZWxlc3MgdW5sZXNzIHNsb3BlIGlzIGNvbnNpc3RlbnQpXG4gICAgLSBkb29yaG9sZSBwYXJlbnRpbmcgaXMgYWx3YXlzIGxldmVsIHRvIHRoZSBob3Jpem9uIGV2ZW4gb24gc2xvcGUtZmxvb3JlZCB3YWxsc1xuICAgIC0gdGhlIHNldFRpbWVvdXQgdGhpbmcgcmVzdWx0cyBpbiBhIG9uZS1mcmFtZSBmbGFzaCBvZiBpbnZpc2libGUgd2FsbHM6IGlzIGl0IHdvcnRoIGl0PyAoaXMgdGhlcmUgYSBzbWFydGVyIHRoaW5nIHRvIGxpc3RlbiBmb3IsIG1heWJlPylcblxuICAgIElTU1VFUyBUSEFUIENPVUxEIFRIRU9SRVRJQ0FMTFkgQkUgRklYRUQgQlVUIERPTidUIFNFRU0gV09SVEggVEhFIFRST1VCTEU6XG4gICAgLSB3YWxscyBhcmUgaW50ZXJuYWxseSByZWFycmFuZ2VkIHRvIGFsd2F5cyB3aW5kIENXLCB3aGljaCBtZWFucyB3YWxsIHBhcmVudGluZyB3aWxsIHBvaW50IHRvd2FyZHMgdGhlIFwicHJldmlvdXNcIiB3YWxsIGlmIHlvdSBlbnRlcmVkIHRoZW0gaW4gQ0NXIG9yZGVyXG5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZmxpcEdlb20gKGdlb20pIHtcbiAgICAgIGNvbnN0IGluZGV4Q29weSA9IGdlb20uaW5kZXg7XG4gICAgICBmb3IgKGxldCBjdXJGYWNlSW5kZXggPSAwOyBjdXJGYWNlSW5kZXggPCBpbmRleENvcHkuY291bnQgLyAzOyBjdXJGYWNlSW5kZXgrKykge1xuICAgICAgICBjb25zdCBidWNrZXQgPSBpbmRleENvcHlbY3VyRmFjZUluZGV4ICogMyArIDJdO1xuICAgICAgICBpbmRleENvcHlbY3VyRmFjZUluZGV4ICogMyArIDJdID0gaW5kZXhDb3B5W2N1ckZhY2VJbmRleCAqIDMgKyAxXTtcbiAgICAgICAgaW5kZXhDb3B5W2N1ckZhY2VJbmRleCAqIDMgKyAxXSA9IGJ1Y2tldDtcbiAgICAgIH1cbiAgICAgIGdlb20uc2V0SW5kZXgoaW5kZXhDb3B5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlVXZzRm9yR2VvbSAoZ2VvbSwgY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGFsbFVWcyA9IFtdO1xuICAgICAgZm9yIChsZXQgZmFjZVZlcnRJbmRleCA9IDA7IGZhY2VWZXJ0SW5kZXggPCBnZW9tLmluZGV4LmFycmF5Lmxlbmd0aDsgZmFjZVZlcnRJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHZlcnRleEluZGV4ID0gZ2VvbS5pbmRleC5hcnJheVtmYWNlVmVydEluZGV4XTtcbiAgICAgICAgY29uc3QgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgICAgZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmdldFgodmVydGV4SW5kZXgpLFxuICAgICAgICAgIGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5nZXRZKHZlcnRleEluZGV4KSxcbiAgICAgICAgICBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uZ2V0Wih2ZXJ0ZXhJbmRleClcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdXYgPSBjYWxsYmFjayh2ZXJ0ZXgsIGZhY2VWZXJ0SW5kZXggJSAzKTtcbiAgICAgICAgYWxsVVZzW3ZlcnRleEluZGV4ICogMiArIDBdID0gdXZbMF07XG4gICAgICAgIGFsbFVWc1t2ZXJ0ZXhJbmRleCAqIDIgKyAxXSA9IHV2WzFdO1xuICAgICAgfVxuICAgICAgZ2VvbS5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGFsbFVWcyksIDIpKTtcbiAgICAgIGdlb20udXZzTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VQbGFuZVV2cyAoZ2VvbSwgdUtleSwgdktleSwgdU11bHQsIHZNdWx0KSB7XG4gICAgICBtYWtlVXZzRm9yR2VvbShnZW9tLCAocHQpID0+IHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBwdFt1S2V5XSAqIHVNdWx0LFxuICAgICAgICAgIHB0W3ZLZXldICogdk11bHRcbiAgICAgICAgXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmlzaEdlb20gKGdlb20pIHtcbiAgICAgIGdlb20uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcbiAgICAgIC8vIGFyZSB0aGVzZSBuZWNlc3Nhcnk/XG4gICAgICBnZW9tLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgICAgZ2VvbS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRVbnNvcnRlZFJvb21XYWxsQXJyYXkgKHJvb21FbCkge1xuICAgICAgY29uc3Qgd2FsbHMgPSBbXTtcbiAgICAgIGZvciAobGV0IHJvb21DaGlsZE5vZGVJbmRleCA9IDA7IHJvb21DaGlsZE5vZGVJbmRleCA8IHJvb21FbC5jaGlsZHJlbi5sZW5ndGg7IHJvb21DaGlsZE5vZGVJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHJvb21DaGlsZE5vZGUgPSByb29tRWwuY2hpbGRyZW5bcm9vbUNoaWxkTm9kZUluZGV4XTtcbiAgICAgICAgaWYgKHJvb21DaGlsZE5vZGUuY29tcG9uZW50cy53YWxsKSB7IHdhbGxzLnB1c2gocm9vbUNoaWxkTm9kZSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB3YWxscztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRSb29tV2FsbEFycmF5IChyb29tRWwpIHtcbiAgICAgIC8vIHRoZSByZXN1bHRzIG9mIHRoaXMgbm90IGJlaW5nIHNhdmVkIGFueXdoZXJlIGlzIHN1cGVyIHdhc3RlZnVsLFxuICAgICAgLy8gYnV0LCBzZWUgYWJvdmU7IG5vdCB3b3J0aCB3b3JyeWluZyBhYm91dCB5ZXRcblxuICAgICAgY29uc3QgaXNPdXRzaWRlID0gcm9vbUVsLmNvbXBvbmVudHMucm9vbS5kYXRhLm91dHNpZGU7XG5cbiAgICAgIGNvbnN0IHdhbGxzID0gZ2V0VW5zb3J0ZWRSb29tV2FsbEFycmF5KHJvb21FbCk7XG5cbiAgICAgIGxldCBjd1N1bSA9IDA7XG4gICAgICBmb3IgKGxldCB3YWxsSW5kZXggPSAwOyB3YWxsSW5kZXggPCB3YWxscy5sZW5ndGg7IHdhbGxJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGN1cldhbGxOb2RlID0gd2FsbHNbd2FsbEluZGV4XTtcbiAgICAgICAgY29uc3QgbmV4dFdhbGxOb2RlID0gd2FsbHNbKHdhbGxJbmRleCArIDEpICUgd2FsbHMubGVuZ3RoXTtcbiAgICAgICAgY29uc3QgY3VyV2FsbFBvcyA9IGN1cldhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YTtcbiAgICAgICAgY29uc3QgbmV4dFdhbGxQb3MgPSBuZXh0V2FsbE5vZGUuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhO1xuXG4gICAgICAgIGN3U3VtICs9IChuZXh0V2FsbFBvcy54IC0gY3VyV2FsbFBvcy54KSAqIChuZXh0V2FsbFBvcy56ICsgY3VyV2FsbFBvcy56KTtcbiAgICAgIH1cblxuICAgICAgbGV0IHNob3VsZFJldmVyc2UgPSBmYWxzZTtcbiAgICAgIGlmIChjd1N1bSA+IDApIHsgc2hvdWxkUmV2ZXJzZSA9ICFzaG91bGRSZXZlcnNlOyB9XG4gICAgICBpZiAoaXNPdXRzaWRlKSB7IHNob3VsZFJldmVyc2UgPSAhc2hvdWxkUmV2ZXJzZTsgfVxuICAgICAgaWYgKHNob3VsZFJldmVyc2UpIHsgd2FsbHMucmV2ZXJzZSgpOyB9XG5cbiAgICAgIHJldHVybiB3YWxscztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TmV4dFdhbGxFbCAod2FsbEVsKSB7XG4gICAgICBjb25zdCB3YWxsTGlzdCA9IGdldFJvb21XYWxsQXJyYXkod2FsbEVsLnBhcmVudE5vZGUpO1xuICAgICAgY29uc3QgY3VyV2FsbEluZGV4ID0gd2FsbExpc3QuaW5kZXhPZih3YWxsRWwpO1xuICAgICAgcmV0dXJuIHdhbGxMaXN0WyhjdXJXYWxsSW5kZXggKyAxKSAlIHdhbGxMaXN0Lmxlbmd0aF07XG4gICAgfVxuXG4gICAgY29uc3Qgd29ybGRXYWxsUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCB3b3JsZE5leHRQb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGNvbnN0IHdvcmxkTGlua1BvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgZnVuY3Rpb24gbW92ZUZvckxpbmsgKGRvb3Job2xlRWwsIGRvb3JsaW5rRWwpIHtcbiAgICAgIGNvbnN0IGhvbGVXYWxsRWwgPSBkb29yaG9sZUVsLnBhcmVudE5vZGU7XG4gICAgICBjb25zdCBuZXh0V2FsbEVsID0gZ2V0TmV4dFdhbGxFbChob2xlV2FsbEVsKTtcbiAgICAgIGlmICghbmV4dFdhbGxFbCkgeyByZXR1cm47IH1cblxuICAgICAgaG9sZVdhbGxFbC5vYmplY3QzRC5nZXRXb3JsZFBvc2l0aW9uKHdvcmxkV2FsbFBvcyk7XG4gICAgICBuZXh0V2FsbEVsLm9iamVjdDNELmdldFdvcmxkUG9zaXRpb24od29ybGROZXh0UG9zKTtcbiAgICAgIGRvb3JsaW5rRWwub2JqZWN0M0QuZ2V0V29ybGRQb3NpdGlvbih3b3JsZExpbmtQb3MpO1xuXG4gICAgICBjb25zdCBsaW5rR2FwWCA9IHdvcmxkTGlua1Bvcy54IC0gd29ybGRXYWxsUG9zLng7XG4gICAgICBjb25zdCBsaW5rR2FwWiA9IHdvcmxkTGlua1Bvcy56IC0gd29ybGRXYWxsUG9zLno7XG5cbiAgICAgIGNvbnN0IHdhbGxHYXBYID0gd29ybGROZXh0UG9zLnggLSB3b3JsZFdhbGxQb3MueDtcbiAgICAgIGNvbnN0IHdhbGxHYXBaID0gd29ybGROZXh0UG9zLnogLSB3b3JsZFdhbGxQb3MuejtcbiAgICAgIGNvbnN0IHdhbGxBbmcgPSBNYXRoLmF0YW4yKHdhbGxHYXBaLCB3YWxsR2FwWCk7XG4gICAgICBjb25zdCB3YWxsTGVuZ3RoID0gTWF0aC5zcXJ0KHdhbGxHYXBYICogd2FsbEdhcFggKyB3YWxsR2FwWiAqIHdhbGxHYXBaKTtcblxuICAgICAgbGV0IGxvY2FsTGlua1ggPSBsaW5rR2FwWCAqIE1hdGguY29zKC13YWxsQW5nKSAtIGxpbmtHYXBaICogTWF0aC5zaW4oLXdhbGxBbmcpO1xuICAgICAgLy8gdmFyIGxvY2FsTGlua1ogPSBsaW5rR2FwWCpNYXRoLnNpbigtd2FsbEFuZykgKyBsaW5rR2FwWipNYXRoLmNvcygtd2FsbEFuZyk7XG5cbiAgICAgIGNvbnN0IGRvb3JIYWxmID0gZG9vcmxpbmtFbC5jb21wb25lbnRzLmRvb3JsaW5rLmRhdGEud2lkdGggLyAyO1xuICAgICAgbG9jYWxMaW5rWCA9IE1hdGgubWF4KGxvY2FsTGlua1gsIGRvb3JIYWxmICsgSEFJUik7XG4gICAgICBsb2NhbExpbmtYID0gTWF0aC5taW4obG9jYWxMaW5rWCwgd2FsbExlbmd0aCAtIGRvb3JIYWxmIC0gSEFJUik7XG5cbiAgICAgIGRvb3Job2xlRWwuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIHsgeDogbG9jYWxMaW5rWCwgeTogMCwgejogMCB9KTtcbiAgICAgIGRvb3Job2xlRWwub2JqZWN0M0QudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRIb2xlTGluayAoZG9vcmhvbGVFbCkge1xuICAgICAgY29uc3QgZG9vcmxpbmtzID0gYnVpbGRpbmdTZWxmLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkb29ybGlua10nKTtcbiAgICAgIGZvciAobGV0IGN1ckxpbmtJbmRleCA9IDA7IGN1ckxpbmtJbmRleCA8IGRvb3JsaW5rcy5sZW5ndGg7IGN1ckxpbmtJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGN1ckxpbmsgPSBkb29ybGlua3NbY3VyTGlua0luZGV4XTtcbiAgICAgICAgaWYgKGN1ckxpbmsuY29tcG9uZW50cy5kb29ybGluay5kYXRhLmZyb20gPT0gZG9vcmhvbGVFbCkgeyByZXR1cm4gY3VyTGluazsgfVxuICAgICAgICBpZiAoY3VyTGluay5jb21wb25lbnRzLmRvb3JsaW5rLmRhdGEudG8gPT0gZG9vcmhvbGVFbCkgeyByZXR1cm4gY3VyTGluazsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdhbGxIZWlnaHQgKHdhbGxFbCkge1xuICAgICAgaWYgKHdhbGxFbC5jb21wb25lbnRzLndhbGwuZGF0YS5oZWlnaHQpIHsgcmV0dXJuIHdhbGxFbC5jb21wb25lbnRzLndhbGwuZGF0YS5oZWlnaHQ7IH1cbiAgICAgIHJldHVybiB3YWxsRWwucGFyZW50Tm9kZS5jb21wb25lbnRzLnJvb20uZGF0YS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKGJ1aWxkaW5nU2VsZi5kaXJ0eSkgeyByZXR1cm47IH1cbiAgICBidWlsZGluZ1NlbGYuZGlydHkgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coXCIgPT0gU1RBUlRJTkcgUkUtRVZBTFVBVElPTi4uLlwiKTtcblxuICAgICAgLy8gc2lsbHkgYnV0IG5lY2Vzc2FyeSBiZWNhdXNlIG9mIHRocmVlSlMgd2VpcmRuZXNzXG4gICAgICBidWlsZGluZ1NlbGYuZWwub2JqZWN0M0QudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgICAgLy8gbGF5IG91dCB3YWxscycgYW5nbGVzOlxuXG4gICAgICBmb3IgKHZhciBzY2VuZUNoaWxkTm9kZUluZGV4ID0gMDsgc2NlbmVDaGlsZE5vZGVJbmRleCA8IGJ1aWxkaW5nU2VsZi5lbC5jaGlsZHJlbi5sZW5ndGg7IHNjZW5lQ2hpbGROb2RlSW5kZXgrKykge1xuICAgICAgICB2YXIgc2NlbmVDaGlsZE5vZGUgPSBidWlsZGluZ1NlbGYuZWwuY2hpbGRyZW5bc2NlbmVDaGlsZE5vZGVJbmRleF07XG4gICAgICAgIGlmIChzY2VuZUNoaWxkTm9kZS5jb21wb25lbnRzICYmIHNjZW5lQ2hpbGROb2RlLmNvbXBvbmVudHMucm9vbSkge1xuICAgICAgICAgIGNvbnN0IHcgPSBzY2VuZUNoaWxkTm9kZS5jb21wb25lbnRzLnJvb20uZGF0YS53aWR0aDtcbiAgICAgICAgICBjb25zdCBsID0gc2NlbmVDaGlsZE5vZGUuY29tcG9uZW50cy5yb29tLmRhdGEubGVuZ3RoO1xuICAgICAgICAgIGlmICh3IHx8IGwpIHtcbiAgICAgICAgICAgIGlmICh3ICYmIGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmF3V2FsbHMgPSBnZXRVbnNvcnRlZFJvb21XYWxsQXJyYXkoc2NlbmVDaGlsZE5vZGUpO1xuICAgICAgICAgICAgICBpZiAocmF3V2FsbHMubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmF3V2FsbHMubGVuZ3RoID4gNCkgeyBjb25zb2xlLmVycm9yKCdyb29tcyB3aXRoIFdJRFRIIGFuZCBMRU5HVEggc2hvdWxkIG9ubHkgaGF2ZSBmb3VyIHdhbGxzIScpOyB9XG4gICAgICAgICAgICAgICAgcmF3V2FsbHNbMF0uc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIHsgeDogMCwgeTogMCwgejogMCB9KTtcbiAgICAgICAgICAgICAgICByYXdXYWxsc1sxXS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgeyB4OiB3LCB5OiAwLCB6OiAwIH0pO1xuICAgICAgICAgICAgICAgIHJhd1dhbGxzWzJdLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCB7IHg6IHcsIHk6IDAsIHo6IGwgfSk7XG4gICAgICAgICAgICAgICAgcmF3V2FsbHNbM10uc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIHsgeDogMCwgeTogMCwgejogbCB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyb29tcyB3aXRoIFdJRFRIIGFuZCBMRU5HVEggbXVzdCBoYXZlIGZvdXIgd2FsbHMhJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3Jvb21zIHdpdGggV0lEVEggbXVzdCBhbHNvIGhhdmUgTEVOR1RIIChhbmQgdmljZSB2ZXJzYSknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgd2FsbHMgPSBnZXRSb29tV2FsbEFycmF5KHNjZW5lQ2hpbGROb2RlKTtcbiAgICAgICAgICBpZiAod2FsbHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgZm9yICh2YXIgd2FsbEluZGV4ID0gMDsgd2FsbEluZGV4IDwgd2FsbHMubGVuZ3RoOyB3YWxsSW5kZXgrKykge1xuICAgICAgICAgICAgICB2YXIgY3VyV2FsbE5vZGUgPSB3YWxsc1t3YWxsSW5kZXhdO1xuICAgICAgICAgICAgICB2YXIgbmV4dFdhbGxOb2RlID0gd2FsbHNbKHdhbGxJbmRleCArIDEpICUgd2FsbHMubGVuZ3RoXTtcblxuICAgICAgICAgICAgICB2YXIgd2FsbEdhcFggPSBuZXh0V2FsbE5vZGUuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLnggLSBjdXJXYWxsTm9kZS5jb21wb25lbnRzLnBvc2l0aW9uLmRhdGEueDtcbiAgICAgICAgICAgICAgdmFyIHdhbGxHYXBaID0gbmV4dFdhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS56IC0gY3VyV2FsbE5vZGUuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLno7XG4gICAgICAgICAgICAgIHZhciB3YWxsQW5nID0gTWF0aC5hdGFuMih3YWxsR2FwWiwgd2FsbEdhcFgpO1xuXG4gICAgICAgICAgICAgIGN1cldhbGxOb2RlLnNldEF0dHJpYnV0ZSgncm90YXRpb24nLCB7IHg6IDAsIHk6IC13YWxsQW5nIC8gTWF0aC5QSSAqIDE4MCwgejogMCB9KTtcbiAgICAgICAgICAgICAgY3VyV2FsbE5vZGUub2JqZWN0M0QudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcG9zaXRpb24gdGhlIGRvb3IgaG9sZXM6XG5cbiAgICAgIGNvbnN0IGRvb3JsaW5rcyA9IGJ1aWxkaW5nU2VsZi5lbC5xdWVyeVNlbGVjdG9yQWxsKCdbZG9vcmxpbmtdJyk7XG4gICAgICBmb3IgKHZhciBjdXJEb29ybGlua0VsSW5kZXggPSAwOyBjdXJEb29ybGlua0VsSW5kZXggPCBkb29ybGlua3MubGVuZ3RoOyBjdXJEb29ybGlua0VsSW5kZXgrKykge1xuICAgICAgICB2YXIgY3VyRG9vcmxpbmtFbCA9IGRvb3JsaW5rc1tjdXJEb29ybGlua0VsSW5kZXhdO1xuICAgICAgICB2YXIgY3VyRG9vcmxpbmsgPSBjdXJEb29ybGlua0VsLmNvbXBvbmVudHMuZG9vcmxpbms7XG4gICAgICAgIGlmICghY3VyRG9vcmxpbmspIHsgcmV0dXJuOyB9Ly8gc3RpbGwgc2V0dGluZyB1cCwgdHJ5IGFnYWluIGxhdGVyXG5cbiAgICAgICAgbW92ZUZvckxpbmsoY3VyRG9vcmxpbmsuZGF0YS5mcm9tLCBjdXJEb29ybGluay5lbCk7XG4gICAgICAgIG1vdmVGb3JMaW5rKGN1ckRvb3JsaW5rLmRhdGEudG8sIGN1ckRvb3JsaW5rLmVsKTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2VuZXJhdGUgdGhlIHdhbGxzJyBnZW9tZXRyeTpcblxuICAgICAgZm9yICh2YXIgc2NlbmVDaGlsZE5vZGVJbmRleCA9IDA7IHNjZW5lQ2hpbGROb2RlSW5kZXggPCBidWlsZGluZ1NlbGYuZWwuY2hpbGRyZW4ubGVuZ3RoOyBzY2VuZUNoaWxkTm9kZUluZGV4KyspIHtcbiAgICAgICAgdmFyIHNjZW5lQ2hpbGROb2RlID0gYnVpbGRpbmdTZWxmLmVsLmNoaWxkcmVuW3NjZW5lQ2hpbGROb2RlSW5kZXhdO1xuICAgICAgICBpZiAoc2NlbmVDaGlsZE5vZGUuY29tcG9uZW50cyAmJiBzY2VuZUNoaWxkTm9kZS5jb21wb25lbnRzLnJvb20pIHtcbiAgICAgICAgICBjb25zdCBpc091dHNpZGUgPSBzY2VuZUNoaWxkTm9kZS5jb21wb25lbnRzLnJvb20uZGF0YS5vdXRzaWRlO1xuICAgICAgICAgIHZhciB3YWxscyA9IGdldFJvb21XYWxsQXJyYXkoc2NlbmVDaGlsZE5vZGUpO1xuXG4gICAgICAgICAgaWYgKHdhbGxzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHdhbGxJbmRleCA9IDA7IHdhbGxJbmRleCA8IHdhbGxzLmxlbmd0aDsgd2FsbEluZGV4KyspIHtcbiAgICAgICAgICAgICAgdmFyIGN1cldhbGxOb2RlID0gd2FsbHNbd2FsbEluZGV4XTtcbiAgICAgICAgICAgICAgdmFyIG5leHRXYWxsTm9kZSA9IHdhbGxzWyh3YWxsSW5kZXggKyAxKSAlIHdhbGxzLmxlbmd0aF07XG5cbiAgICAgICAgICAgICAgdmFyIHdhbGxHYXBYID0gbmV4dFdhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS54IC0gY3VyV2FsbE5vZGUuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLng7XG4gICAgICAgICAgICAgIHZhciB3YWxsR2FwWiA9IG5leHRXYWxsTm9kZS5jb21wb25lbnRzLnBvc2l0aW9uLmRhdGEueiAtIGN1cldhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS56O1xuICAgICAgICAgICAgICBjb25zdCB3YWxsTGVuZ3RoID0gTWF0aC5zcXJ0KHdhbGxHYXBYICogd2FsbEdhcFggKyB3YWxsR2FwWiAqIHdhbGxHYXBaKTtcbiAgICAgICAgICAgICAgdmFyIHdhbGxBbmcgPSBNYXRoLmF0YW4yKHdhbGxHYXBaLCB3YWxsR2FwWCk7XG5cbiAgICAgICAgICAgICAgY29uc3Qgd2FsbEdhcFkgPSBuZXh0V2FsbE5vZGUuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLnkgLSBjdXJXYWxsTm9kZS5jb21wb25lbnRzLnBvc2l0aW9uLmRhdGEueTtcbiAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0R2FwID0gZ2V0V2FsbEhlaWdodChuZXh0V2FsbE5vZGUpIC0gZ2V0V2FsbEhlaWdodChjdXJXYWxsTm9kZSk7XG5cbiAgICAgICAgICAgICAgY29uc3Qgb3JkZXJlZEhvbGVzID0gW107XG4gICAgICAgICAgICAgIGZvciAobGV0IHdhbGxDaGlsZE5vZGVJbmRleCA9IDA7IHdhbGxDaGlsZE5vZGVJbmRleCA8IGN1cldhbGxOb2RlLmNoaWxkcmVuLmxlbmd0aDsgd2FsbENoaWxkTm9kZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YWxsQ2hpbGROb2RlID0gY3VyV2FsbE5vZGUuY2hpbGRyZW5bd2FsbENoaWxkTm9kZUluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAod2FsbENoaWxkTm9kZS5jb21wb25lbnRzICYmIHdhbGxDaGlsZE5vZGUuY29tcG9uZW50cy5kb29yaG9sZSkge1xuICAgICAgICAgICAgICAgICAgb3JkZXJlZEhvbGVzLnB1c2god2FsbENoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9yZGVyZWRIb2xlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLnggLSBiLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS54O1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjb25zdCB3YWxsU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcbiAgICAgICAgICAgICAgd2FsbFNoYXBlLm1vdmVUbyhcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIGdldFdhbGxIZWlnaHQoY3VyV2FsbE5vZGUpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHdhbGxTaGFwZS5saW5lVG8oXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgZm9yIChsZXQgaG9sZUluZGV4ID0gMDsgaG9sZUluZGV4IDwgb3JkZXJlZEhvbGVzLmxlbmd0aDsgaG9sZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaG9sZUVsID0gb3JkZXJlZEhvbGVzW2hvbGVJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCFob2xlRWwubXlWZXJ0cykgeyBob2xlRWwubXlWZXJ0cyA9IFtdOyB9XG4gICAgICAgICAgICAgICAgaG9sZUVsLm15VmVydHMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtFbCA9IGdldEhvbGVMaW5rKG9yZGVyZWRIb2xlc1tob2xlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmtFbCkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaG9sZUluZm8gPSBob2xlRWwuY29tcG9uZW50cztcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rSW5mbyA9IGxpbmtFbC5jb21wb25lbnRzO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaG9sZVNpZGUgPSAtMTsgaG9sZVNpZGUgPD0gMTsgaG9sZVNpZGUgKz0gMikge1xuICAgICAgICAgICAgICAgICAgdmFyIHB0WCA9IGhvbGVJbmZvLnBvc2l0aW9uLmRhdGEueCArIGxpbmtJbmZvLmRvb3JsaW5rLmRhdGEud2lkdGggLyAyICogaG9sZVNpZGU7XG4gICAgICAgICAgICAgICAgICBjb25zdCBmbG9vclkgPSAocHRYIC8gd2FsbExlbmd0aCkgKiB3YWxsR2FwWTtcbiAgICAgICAgICAgICAgICAgIGxldCB0b3BZID0gZmxvb3JZICsgbGlua0luZm8uZG9vcmxpbmsuZGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ckNlaWwgPSBnZXRXYWxsSGVpZ2h0KGN1cldhbGxOb2RlKSArIChwdFggLyB3YWxsTGVuZ3RoKSAqIGhlaWdodEdhcDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1heFRvcFkgPSBmbG9vclkgKyBjdXJDZWlsIC0gSEFJUjsvLyB3aWxsIGFsd2F5cyBiZSBhIHNlYW0sIGJ1dCwgSSdtIG5vdCBib3RoZXJpbmcgdG8gcmV3cml0ZSBqdXN0IGZvciB0aGF0XG4gICAgICAgICAgICAgICAgICBpZiAodG9wWSA+IG1heFRvcFkpIHsgdG9wWSA9IG1heFRvcFk7IH1cblxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkV29ybGRWZXJ0IChwdFkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcFBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKHB0WCwgcHRZLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY3VyV2FsbE5vZGUub2JqZWN0M0QubG9jYWxUb1dvcmxkKHRlbXBQb3MpO1xuICAgICAgICAgICAgICAgICAgICBob2xlRWwubXlWZXJ0cy5wdXNoKHRlbXBQb3MpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0KGZsb29yWSk7XG4gICAgICAgICAgICAgICAgICBhZGRXb3JsZFZlcnQodG9wWSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChob2xlU2lkZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd2FsbFNoYXBlLmxpbmVUbyhwdFgsIGZsb29yWSk7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxTaGFwZS5saW5lVG8ocHRYLCB0b3BZKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxTaGFwZS5saW5lVG8ocHRYLCB0b3BZKTtcbiAgICAgICAgICAgICAgICAgICAgd2FsbFNoYXBlLmxpbmVUbyhwdFgsIGZsb29yWSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgd2FsbFNoYXBlLmxpbmVUbyhcbiAgICAgICAgICAgICAgICB3YWxsTGVuZ3RoLFxuICAgICAgICAgICAgICAgIG5leHRXYWxsTm9kZS5jb21wb25lbnRzLnBvc2l0aW9uLmRhdGEueSAtIGN1cldhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS55XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHdhbGxTaGFwZS5saW5lVG8oXG4gICAgICAgICAgICAgICAgd2FsbExlbmd0aCxcbiAgICAgICAgICAgICAgICAobmV4dFdhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS55IC0gY3VyV2FsbE5vZGUuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLnkpICsgZ2V0V2FsbEhlaWdodChuZXh0V2FsbE5vZGUpXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgY29uc3Qgd2FsbEdlb20gPSBuZXcgVEhSRUUuU2hhcGVHZW9tZXRyeSh3YWxsU2hhcGUpO1xuICAgICAgICAgICAgICBtYWtlUGxhbmVVdnMod2FsbEdlb20sICd4JywgJ3knLCAxLCAxKTtcbiAgICAgICAgICAgICAgZmluaXNoR2VvbSh3YWxsR2VvbSk7XG4gICAgICAgICAgICAgIHZhciBteU1hdCA9IGN1cldhbGxOb2RlLmNvbXBvbmVudHMubWF0ZXJpYWwgPyBjdXJXYWxsTm9kZS5jb21wb25lbnRzLm1hdGVyaWFsLm1hdGVyaWFsIDogY3VyV2FsbE5vZGUucGFyZW50Tm9kZS5jb21wb25lbnRzLm1hdGVyaWFsLm1hdGVyaWFsO1xuICAgICAgICAgICAgICBpZiAoY3VyV2FsbE5vZGUubXlNZXNoKSB7XG4gICAgICAgICAgICAgICAgY3VyV2FsbE5vZGUubXlNZXNoLmdlb21ldHJ5ID0gd2FsbEdlb207XG4gICAgICAgICAgICAgICAgY3VyV2FsbE5vZGUubXlNZXNoLm1hdGVyaWFsID0gbXlNYXQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyV2FsbE5vZGUubXlNZXNoID0gbmV3IFRIUkVFLk1lc2god2FsbEdlb20sIG15TWF0KTtcbiAgICAgICAgICAgICAgICBjdXJXYWxsTm9kZS5zZXRPYmplY3QzRCgnd2FsbE1lc2gnLCBjdXJXYWxsTm9kZS5teU1lc2gpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNhcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHJvb21DaGlsZE5vZGVJbmRleCA9IDA7IHJvb21DaGlsZE5vZGVJbmRleCA8IHNjZW5lQ2hpbGROb2RlLmNoaWxkcmVuLmxlbmd0aDsgcm9vbUNoaWxkTm9kZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgY29uc3Qgcm9vbUNoaWxkTm9kZSA9IHNjZW5lQ2hpbGROb2RlLmNoaWxkcmVuW3Jvb21DaGlsZE5vZGVJbmRleF07XG4gICAgICAgICAgICAgIGlmIChyb29tQ2hpbGROb2RlLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocm9vbUNoaWxkTm9kZS5jb21wb25lbnRzLmZsb29yIHx8IHJvb21DaGlsZE5vZGUuY29tcG9uZW50cy5jZWlsaW5nKSB7IGNhcHMucHVzaChyb29tQ2hpbGROb2RlKTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjdXJDYXBOb2RlSW5kZXggPSAwOyBjdXJDYXBOb2RlSW5kZXggPCBjYXBzLmxlbmd0aDsgY3VyQ2FwTm9kZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VyQ2FwTm9kZSA9IGNhcHNbY3VyQ2FwTm9kZUluZGV4XTtcbiAgICAgICAgICAgICAgY29uc3QgaXNDZWlsaW5nID0gY3VyQ2FwTm9kZS5jb21wb25lbnRzLmNlaWxpbmc7XG5cbiAgICAgICAgICAgICAgY29uc3QgY2FwU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgd2FsbEluZGV4ID0gMDsgd2FsbEluZGV4IDwgd2FsbHMubGVuZ3RoOyB3YWxsSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJXYWxsTm9kZSA9IHdhbGxzW3dhbGxJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIHB0WCA9IGN1cldhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS54O1xuICAgICAgICAgICAgICAgIGNvbnN0IHB0WiA9IGN1cldhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS56O1xuICAgICAgICAgICAgICAgIGlmICh3YWxsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIGNhcFNoYXBlLmxpbmVUbyhwdFgsIHB0Wik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNhcFNoYXBlLm1vdmVUbyhwdFgsIHB0Wik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGNhcEdlb20gPSBuZXcgVEhSRUUuU2hhcGVHZW9tZXRyeShjYXBTaGFwZSk7XG4gICAgICAgICAgICAgIGZvciAodmFyIHdhbGxJbmRleCA9IDA7IHdhbGxJbmRleCA8IHdhbGxzLmxlbmd0aDsgd2FsbEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyV2FsbE5vZGUgPSB3YWxsc1t3YWxsSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clZlcnQgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICAgICAgICAgIGNhcEdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5nZXRYKHdhbGxJbmRleCksXG4gICAgICAgICAgICAgICAgICBjYXBHZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uZ2V0WSh3YWxsSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgY2FwR2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmdldFood2FsbEluZGV4KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3VyVmVydC5zZXQoY3VyVmVydC54LCBjdXJXYWxsTm9kZS5jb21wb25lbnRzLnBvc2l0aW9uLmRhdGEueSwgY3VyVmVydC55KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNDZWlsaW5nKSB7IGN1clZlcnQueSArPSBnZXRXYWxsSGVpZ2h0KGN1cldhbGxOb2RlKTsgfVxuICAgICAgICAgICAgICAgIGNhcEdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5zZXRYWVood2FsbEluZGV4LCBjdXJWZXJ0LngsIGN1clZlcnQueSwgY3VyVmVydC56KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCBzaG91bGRSZXZlcnNlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmICghaXNDZWlsaW5nKSB7IHNob3VsZFJldmVyc2UgPSAhc2hvdWxkUmV2ZXJzZTsgfVxuICAgICAgICAgICAgICBpZiAoaXNPdXRzaWRlKSB7IHNob3VsZFJldmVyc2UgPSAhc2hvdWxkUmV2ZXJzZTsgfVxuICAgICAgICAgICAgICBpZiAoc2hvdWxkUmV2ZXJzZSkgeyBmbGlwR2VvbShjYXBHZW9tKTsgfVxuXG4gICAgICAgICAgICAgIG1ha2VQbGFuZVV2cyhjYXBHZW9tLCAneCcsICd6JywgaXNDZWlsaW5nID8gMSA6IC0xLCAxKTtcbiAgICAgICAgICAgICAgZmluaXNoR2VvbShjYXBHZW9tKTtcblxuICAgICAgICAgICAgICBpZiAoIWN1ckNhcE5vZGUubXlNZXNoZXMpIHsgY3VyQ2FwTm9kZS5teU1lc2hlcyA9IFtdOyB9XG5cbiAgICAgICAgICAgICAgY29uc3QgdHlwZUxhYmVsID0gaXNDZWlsaW5nID8gJ2NlaWxpbmcnIDogJ2Zsb29yJztcbiAgICAgICAgICAgICAgdmFyIG15TWF0ID0gY3VyQ2FwTm9kZS5jb21wb25lbnRzLm1hdGVyaWFsID8gY3VyQ2FwTm9kZS5jb21wb25lbnRzLm1hdGVyaWFsLm1hdGVyaWFsIDogY3VyQ2FwTm9kZS5wYXJlbnROb2RlLmNvbXBvbmVudHMubWF0ZXJpYWwubWF0ZXJpYWw7XG4gICAgICAgICAgICAgIGlmIChjdXJDYXBOb2RlLm15TWVzaGVzW3R5cGVMYWJlbF0pIHtcbiAgICAgICAgICAgICAgICBjdXJDYXBOb2RlLm15TWVzaGVzW3R5cGVMYWJlbF0uZ2VvbWV0cnkgPSBjYXBHZW9tO1xuICAgICAgICAgICAgICAgIGN1ckNhcE5vZGUubXlNZXNoZXNbdHlwZUxhYmVsXS5tYXRlcmlhbCA9IG15TWF0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1ckNhcE5vZGUubXlNZXNoZXNbdHlwZUxhYmVsXSA9IG5ldyBUSFJFRS5NZXNoKGNhcEdlb20sIG15TWF0KTtcbiAgICAgICAgICAgICAgICBjdXJDYXBOb2RlLnNldE9iamVjdDNEKHR5cGVMYWJlbCwgY3VyQ2FwTm9kZS5teU1lc2hlc1t0eXBlTGFiZWxdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnZW5lcmF0ZSB0aGUgZG9vciB0dW5uZWxzJyBnZW9tZXRyeTpcblxuICAgICAgZm9yICh2YXIgY3VyRG9vcmxpbmtFbEluZGV4ID0gMDsgY3VyRG9vcmxpbmtFbEluZGV4IDwgZG9vcmxpbmtzLmxlbmd0aDsgY3VyRG9vcmxpbmtFbEluZGV4KyspIHtcbiAgICAgICAgdmFyIGN1ckRvb3JsaW5rRWwgPSBkb29ybGlua3NbY3VyRG9vcmxpbmtFbEluZGV4XTtcblxuICAgICAgICB2YXIgY3VyRG9vcmxpbmsgPSBjdXJEb29ybGlua0VsLmNvbXBvbmVudHMuZG9vcmxpbms7XG4gICAgICAgIGlmICghY3VyRG9vcmxpbmsuZGF0YS5mcm9tKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghY3VyRG9vcmxpbmsuZGF0YS50bykgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAoIWN1ckRvb3JsaW5rLmRhdGEuZnJvbS5teVZlcnRzKSB7IHJldHVybjsgfVxuICAgICAgICBpZiAoIWN1ckRvb3JsaW5rLmRhdGEudG8ubXlWZXJ0cykgeyByZXR1cm47IH1cblxuICAgICAgICBmb3IgKGxldCBkb29yTGlua0NoaWxkSW5kZXggPSAwOyBkb29yTGlua0NoaWxkSW5kZXggPCBjdXJEb29ybGlua0VsLmNoaWxkcmVuLmxlbmd0aDsgZG9vckxpbmtDaGlsZEluZGV4KyspIHtcbiAgICAgICAgICB2YXIgZG9vckxpbmtDaGlsZCA9IGN1ckRvb3JsaW5rRWwuY2hpbGRyZW5bZG9vckxpbmtDaGlsZEluZGV4XTtcbiAgICAgICAgICBpZiAoIWRvb3JMaW5rQ2hpbGQuY29tcG9uZW50cykgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgY29uc3QgdHlwZXMgPSBbJ3NpZGVzJywgJ2Zsb29yJywgJ2NlaWxpbmcnXTtcbiAgICAgICAgICBmb3IgKGxldCBjdXJUeXBlSW5kZXggPSAwOyBjdXJUeXBlSW5kZXggPCB0eXBlcy5sZW5ndGg7IGN1clR5cGVJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJUeXBlID0gdHlwZXNbY3VyVHlwZUluZGV4XTtcblxuICAgICAgICAgICAgaWYgKCFkb29yTGlua0NoaWxkLmNvbXBvbmVudHNbY3VyVHlwZV0pIHsgY29udGludWU7IH1cblxuICAgICAgICAgICAgdmFyIG15TWF0ID0gZG9vckxpbmtDaGlsZC5jb21wb25lbnRzLm1hdGVyaWFsID8gZG9vckxpbmtDaGlsZC5jb21wb25lbnRzLm1hdGVyaWFsLm1hdGVyaWFsIDogZG9vckxpbmtDaGlsZC5wYXJlbnROb2RlLmNvbXBvbmVudHMubWF0ZXJpYWwubWF0ZXJpYWw7XG5cbiAgICAgICAgICAgIGlmICghZG9vckxpbmtDaGlsZC5teUdlb21zKSB7IGRvb3JMaW5rQ2hpbGQubXlHZW9tcyA9IFtdOyB9XG4gICAgICAgICAgICBpZiAoIWRvb3JMaW5rQ2hpbGQubXlHZW9tc1tjdXJUeXBlXSkge1xuICAgICAgICAgICAgICB2YXIgY3VyR2VvbSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgICAgICAgICAgICBkb29yTGlua0NoaWxkLm15R2VvbXNbY3VyVHlwZV0gPSBjdXJHZW9tO1xuICAgICAgICAgICAgICBjb25zdCBteU1lc2ggPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgICAgICAgICAgICBjdXJHZW9tLFxuICAgICAgICAgICAgICAgIG15TWF0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGN1ckdlb20ubWVzaFJlZiA9IG15TWVzaDtcbiAgICAgICAgICAgICAgZG9vckxpbmtDaGlsZC5zZXRPYmplY3QzRChjdXJUeXBlLCBteU1lc2gpO1xuICAgICAgICAgICAgICBjb25zdCBpbmRleEFycmF5ID0gW107XG4gICAgICAgICAgICAgIGluZGV4QXJyYXkucHVzaCgwLCAxLCAyLCAxLCAzLCAyKTtcbiAgICAgICAgICAgICAgaWYgKGN1clR5cGUgPT0gJ3NpZGVzJykgeyBpbmRleEFycmF5LnB1c2goNCwgNSwgNiwgNSwgNywgNik7IH1cbiAgICAgICAgICAgICAgY3VyR2VvbS5zZXRJbmRleChpbmRleEFycmF5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1ckdlb20gPSBkb29yTGlua0NoaWxkLm15R2VvbXNbY3VyVHlwZV07XG4gICAgICAgICAgICBjdXJHZW9tLm1lc2hSZWYubWF0ZXJpYWwgPSBteU1hdDtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkFycmF5ID0gW107XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRXb3JsZFZlcnRleCAocHQpIHtcbiAgICAgICAgICAgICAgY29uc3QgbG9jYWxQdCA9IHB0LmNsb25lKCk7XG4gICAgICAgICAgICAgIGRvb3JMaW5rQ2hpbGQub2JqZWN0M0Qud29ybGRUb0xvY2FsKGxvY2FsUHQpO1xuICAgICAgICAgICAgICBwb3NpdGlvbkFycmF5LnB1c2gobG9jYWxQdC54LCBsb2NhbFB0LnksIGxvY2FsUHQueik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjb21taXRWZXJ0aWNlcyAoKSB7XG4gICAgICAgICAgICAgIGN1ckdlb20uc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbkFycmF5KSwgMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZlZlcnRzID0gY3VyRG9vcmxpbmsuZGF0YS5mcm9tLm15VmVydHM7XG4gICAgICAgICAgICBjb25zdCB0VmVydHMgPSBjdXJEb29ybGluay5kYXRhLnRvLm15VmVydHM7XG4gICAgICAgICAgICBzd2l0Y2ggKGN1clR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnZmxvb3InOlxuXG4gICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0ZXgodFZlcnRzWzBdKTtcbiAgICAgICAgICAgICAgICBhZGRXb3JsZFZlcnRleCh0VmVydHNbMl0pO1xuICAgICAgICAgICAgICAgIGFkZFdvcmxkVmVydGV4KGZWZXJ0c1syXSk7XG4gICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0ZXgoZlZlcnRzWzBdKTtcblxuICAgICAgICAgICAgICAgIGNvbW1pdFZlcnRpY2VzKCk7XG5cbiAgICAgICAgICAgICAgICBtYWtlVXZzRm9yR2VvbShjdXJHZW9tLCAocHQsIHZlcnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgMSAtICh2ZXJ0SW5kZXggJSAyKSxcbiAgICAgICAgICAgICAgICAgICAgMSAtIE1hdGguZmxvb3IodmVydEluZGV4IC8gMilcbiAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnY2VpbGluZyc6XG5cbiAgICAgICAgICAgICAgICBhZGRXb3JsZFZlcnRleCh0VmVydHNbM10pO1xuICAgICAgICAgICAgICAgIGFkZFdvcmxkVmVydGV4KHRWZXJ0c1sxXSk7XG4gICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0ZXgoZlZlcnRzWzFdKTtcbiAgICAgICAgICAgICAgICBhZGRXb3JsZFZlcnRleChmVmVydHNbM10pO1xuXG4gICAgICAgICAgICAgICAgY29tbWl0VmVydGljZXMoKTtcblxuICAgICAgICAgICAgICAgIG1ha2VVdnNGb3JHZW9tKGN1ckdlb20sIChwdCwgdmVydEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0SW5kZXggJSAyLFxuICAgICAgICAgICAgICAgICAgICAxIC0gTWF0aC5mbG9vcih2ZXJ0SW5kZXggLyAyKVxuICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdzaWRlcyc6XG5cbiAgICAgICAgICAgICAgICBhZGRXb3JsZFZlcnRleCh0VmVydHNbMl0pO1xuICAgICAgICAgICAgICAgIGFkZFdvcmxkVmVydGV4KHRWZXJ0c1szXSk7XG4gICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0ZXgoZlZlcnRzWzBdKTtcbiAgICAgICAgICAgICAgICBhZGRXb3JsZFZlcnRleChmVmVydHNbMV0pO1xuXG4gICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0ZXgoZlZlcnRzWzJdKTtcbiAgICAgICAgICAgICAgICBhZGRXb3JsZFZlcnRleChmVmVydHNbM10pO1xuICAgICAgICAgICAgICAgIGFkZFdvcmxkVmVydGV4KHRWZXJ0c1swXSk7XG4gICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0ZXgodFZlcnRzWzFdKTtcblxuICAgICAgICAgICAgICAgIGNvbW1pdFZlcnRpY2VzKCk7XG5cbiAgICAgICAgICAgICAgICBtYWtlVXZzRm9yR2VvbShjdXJHZW9tLCAocHQsIHZlcnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdXYgPSBbXTtcbiAgICAgICAgICAgICAgICAgIHV2WzBdID0gTWF0aC5mbG9vcih2ZXJ0SW5kZXggLyAyKTtcbiAgICAgICAgICAgICAgICAgIHV2WzFdID0gdmVydEluZGV4ICUgMjtcbiAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0SW5kZXggPCA0KSB7IHV2WzBdID0gMSAtIHV2WzBdOyB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdXY7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmlzaEdlb20oY3VyR2VvbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiID09PSBSRS1FVkFMVUFUSU9OIENPTVBMRVRFIVwiKTtcbiAgICAgIGJ1aWxkaW5nU2VsZi5kaXJ0eSA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTY2VuZSAobGFzdFNjZW5lKSB7XG4gIGlmIChsYXN0U2NlbmUgJiYgbGFzdFNjZW5lLnN5c3RlbXMuYnVpbGRpbmcpIHsgbGFzdFNjZW5lLnN5c3RlbXMuYnVpbGRpbmcucmVleGFtaW5lQnVpbGRpbmcoKTsgfVxufVxuZnVuY3Rpb24gcG9zaXRpb25XYXRjaCAoZSkge1xuICBpZiAoZS5kZXRhaWwubmFtZSA9PSAncG9zaXRpb24nKSB7IHVwZGF0ZVNjZW5lKGUuZGV0YWlsLnRhcmdldC5zY2VuZUVsKTsgfVxufVxuXG5mdW5jdGlvbiBub2RlU2NlbmVJbml0ICgpIHtcbiAgdGhpcy5sYXN0U2NlbmUgPSB0aGlzLmVsLnNjZW5lRWw7XG4gIHVwZGF0ZVNjZW5lKHRoaXMubGFzdFNjZW5lKTtcbiAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb25lbnRjaGFuZ2VkJywgcG9zaXRpb25XYXRjaCk7XG59XG5mdW5jdGlvbiBub2RlU2NlbmVVcGRhdGUgKCkge1xuICB1cGRhdGVTY2VuZSh0aGlzLmxhc3RTY2VuZSk7XG59XG5mdW5jdGlvbiBub2RlU2NlbmVSZW1vdmUgKCkge1xuICB1cGRhdGVTY2VuZSh0aGlzLmxhc3RTY2VuZSk7XG4gIHRoaXMubGFzdFNjZW5lID0gbnVsbDtcbiAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb21wb25lbnRjaGFuZ2VkJywgcG9zaXRpb25XYXRjaCk7XG59XG5cbmNvbnN0IHJlZnJlc2hTY2VuZUNvbmZpZyA9IHtcbiAgaW5pdDogbm9kZVNjZW5lSW5pdCxcbiAgdXBkYXRlOiBub2RlU2NlbmVVcGRhdGUsXG4gIHJlbW92ZTogbm9kZVNjZW5lUmVtb3ZlXG59O1xuXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ3Jvb20nLCBPYmplY3QuYXNzaWduKHtcblxuICBzY2hlbWE6IHtcbiAgICBvdXRzaWRlOiB7IHR5cGU6ICdib29sZWFuJyB9LFxuICAgIGhlaWdodDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMi40IH0sXG4gICAgd2lkdGg6IHsgdHlwZTogJ251bWJlcicgfSxcbiAgICBsZW5ndGg6IHsgdHlwZTogJ251bWJlcicgfVxuICB9XG5cbn0sIHJlZnJlc2hTY2VuZUNvbmZpZykpO1xuXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ3dhbGwnLCBPYmplY3QuYXNzaWduKHtcblxuICBzY2hlbWE6IHtcbiAgICBoZWlnaHQ6IHsgdHlwZTogJ251bWJlcicgfVxuICB9XG5cbn0sIHJlZnJlc2hTY2VuZUNvbmZpZykpO1xuXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ2Zsb29yJywgcmVmcmVzaFNjZW5lQ29uZmlnKTtcbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnY2VpbGluZycsIHJlZnJlc2hTY2VuZUNvbmZpZyk7XG5cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnZG9vcmhvbGUnLCByZWZyZXNoU2NlbmVDb25maWcpO1xuXG5BRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ2Rvb3JsaW5rJywgT2JqZWN0LmFzc2lnbih7XG5cbiAgc2NoZW1hOiB7XG4gICAgZnJvbTogeyB0eXBlOiAnc2VsZWN0b3InIH0sXG4gICAgdG86IHsgdHlwZTogJ3NlbGVjdG9yJyB9LFxuICAgIGhlaWdodDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMi4wIH0sXG4gICAgd2lkdGg6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDAuOCB9XG4gIH1cblxufSwgcmVmcmVzaFNjZW5lQ29uZmlnKSk7XG5cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnc2lkZXMnLCByZWZyZXNoU2NlbmVDb25maWcpO1xuXG4vLyBjb3VsZCBwcm9iYWJseSBhdXRvbWF0ZSB0aGlzIHJhdGhlciB0aGFuIGhhcmQtY29kaW5nIGl0LCBidXQgdGhpcydsbCBkbyBmb3Igbm93OlxuXG5BRlJBTUUucmVnaXN0ZXJQcmltaXRpdmUoJ3J3LXJvb20nLCB7XG4gIGRlZmF1bHRDb21wb25lbnRzOiB7IHJvb206IHt9IH0sXG4gIG1hcHBpbmdzOiB7XG4gICAgb3V0c2lkZTogJ3Jvb20ub3V0c2lkZScsXG4gICAgaGVpZ2h0OiAncm9vbS5oZWlnaHQnLFxuICAgIHdpZHRoOiAncm9vbS53aWR0aCcsXG4gICAgbGVuZ3RoOiAncm9vbS5sZW5ndGgnXG4gIH1cbn0pO1xuXG5BRlJBTUUucmVnaXN0ZXJQcmltaXRpdmUoJ3J3LXdhbGwnLCB7XG4gIGRlZmF1bHRDb21wb25lbnRzOiB7IHdhbGw6IHt9IH0sXG4gIG1hcHBpbmdzOiB7XG4gICAgaGVpZ2h0OiAnd2FsbC5oZWlnaHQnXG4gIH1cbn0pO1xuXG5BRlJBTUUucmVnaXN0ZXJQcmltaXRpdmUoJ3J3LWZsb29yJywge1xuICBkZWZhdWx0Q29tcG9uZW50czogeyBmbG9vcjoge30gfSxcbiAgbWFwcGluZ3M6IHt9XG59KTtcblxuQUZSQU1FLnJlZ2lzdGVyUHJpbWl0aXZlKCdydy1jZWlsaW5nJywge1xuICBkZWZhdWx0Q29tcG9uZW50czogeyBjZWlsaW5nOiB7fSB9LFxuICBtYXBwaW5nczoge31cbn0pO1xuXG5BRlJBTUUucmVnaXN0ZXJQcmltaXRpdmUoJ3J3LWRvb3Job2xlJywge1xuICBkZWZhdWx0Q29tcG9uZW50czogeyBkb29yaG9sZToge30gfSxcbiAgbWFwcGluZ3M6IHt9XG59KTtcblxuQUZSQU1FLnJlZ2lzdGVyUHJpbWl0aXZlKCdydy1kb29ybGluaycsIHtcbiAgZGVmYXVsdENvbXBvbmVudHM6IHsgZG9vcmxpbms6IHt9IH0sXG4gIG1hcHBpbmdzOiB7XG4gICAgZnJvbTogJ2Rvb3JsaW5rLmZyb20nLFxuICAgIHRvOiAnZG9vcmxpbmsudG8nLFxuICAgIGhlaWdodDogJ2Rvb3JsaW5rLmhlaWdodCcsXG4gICAgd2lkdGg6ICdkb29ybGluay53aWR0aCdcbiAgfVxufSk7XG5cbkFGUkFNRS5yZWdpc3RlclByaW1pdGl2ZSgncnctc2lkZXMnLCB7XG4gIGRlZmF1bHRDb21wb25lbnRzOiB7IHNpZGVzOiB7fSB9LFxuICBtYXBwaW5nczoge31cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"]();
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});