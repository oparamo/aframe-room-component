/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (() => {

eval("AFRAME.registerSystem('building', {\n\n  reexamineBuilding: function () {\n\n    //console.log(\" = REEVALUATION REQUESTED...\");\n\n    const buildingSelf = this;\n    const HAIR = 0.0001;\n\n    /*\n\n    https://github.com/oparamo/aframe-room-component\n    v0.4.1\n\n    OPTIMIZATION:\n\n    currently, the entire building is getting re-generated from scratch any time anything in it changes.\n    obviously this is wasteful, but:\n    - this library isn't particularly likely to be used in a context where these properties will be changing at runtime (at least outside of debugging)\n    - right now I am more concerned with getting it out the door than making it perfect anyway\n\n    PLANNED FEATURES TO COME (in order):\n    - greater control over UV generation\n    - automatic collision assignment\n    - doors lifted above the ground (i.e. windows)\n    - accept a shape to be extruded around a doorhole to make a doorframe (& around a floor to make a baseboard)\n\n    KNOWN ISSUES (with no obvious solution that would preserve ease of use):\n    - floor/ceiling triangulation is not controllable (and therefore varying wall verticality is nearly useless unless slope is consistent)\n    - doorhole parenting is always level to the horizon even on slope-floored walls\n    - the setTimeout thing results in a one-frame flash of invisible walls: is it worth it? (is there a smarter thing to listen for, maybe?)\n\n    ISSUES THAT COULD THEORETICALLY BE FIXED BUT DON'T SEEM WORTH THE TROUBLE:\n    - walls are internally rearranged to always wind CW, which means wall parenting will point towards the \"previous\" wall if you entered them in CCW order\n\n    */\n\n    function flipGeom(geom) {\n      const indexCopy = geom.index;\n      for (let curFaceIndex = 0; curFaceIndex < indexCopy.count / 3; curFaceIndex++) {\n        const bucket = indexCopy[curFaceIndex * 3 + 2];\n        indexCopy[curFaceIndex * 3 + 2] = indexCopy[curFaceIndex * 3 + 1];\n        indexCopy[curFaceIndex * 3 + 1] = bucket;\n      }\n      geom.setIndex(indexCopy);\n    }\n\n    function makeUvsForGeom(geom, callback) {\n      const allUVs = [];\n      for (let faceVertIndex = 0; faceVertIndex < geom.index.array.length; faceVertIndex++) {\n        const vertexIndex = geom.index.array[faceVertIndex];\n        const vertex = new THREE.Vector3(\n          geom.attributes.position.getX(vertexIndex),\n          geom.attributes.position.getY(vertexIndex),\n          geom.attributes.position.getZ(vertexIndex)\n        );\n        const uv = callback(vertex, faceVertIndex % 3);\n        allUVs[vertexIndex * 2 + 0] = uv[0];\n        allUVs[vertexIndex * 2 + 1] = uv[1];\n      }\n      geom.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(allUVs), 2));\n      geom.uvsNeedUpdate = true;\n\n    }\n    function makePlaneUvs(geom, uKey, vKey, uMult, vMult) {\n      makeUvsForGeom(geom, (pt) => {\n        return [\n          pt[uKey] * uMult,\n          pt[vKey] * vMult\n        ];\n      });\n    }\n\n    function finishGeom(geom) {\n      geom.computeVertexNormals();\n      // are these necessary?\n      geom.computeBoundingBox();\n      geom.computeBoundingSphere();\n    }\n\n    function getUnsortedRoomWallArray(roomEl) {\n      const walls = [];\n      for (let roomChildNodeIndex = 0; roomChildNodeIndex < roomEl.children.length; roomChildNodeIndex++) {\n        const roomChildNode = roomEl.children[roomChildNodeIndex];\n        if (roomChildNode.components.wall) { walls.push(roomChildNode); }\n      }\n      return walls;\n    }\n\n    function getRoomWallArray(roomEl) {\n\n      // the results of this not being saved anywhere is super wasteful,\n      // but, see above; not worth worrying about yet\n\n      const isOutside = roomEl.components.room.data.outside;\n\n      const walls = getUnsortedRoomWallArray(roomEl);\n\n      let cwSum = 0;\n      for (let wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n        const curWallNode = walls[wallIndex];\n        const nextWallNode = walls[(wallIndex + 1) % walls.length];\n        const curWallPos = curWallNode.components.position.data;\n        const nextWallPos = nextWallNode.components.position.data;\n\n        cwSum += (nextWallPos.x - curWallPos.x) * (nextWallPos.z + curWallPos.z);\n\n      }\n\n      let shouldReverse = false;\n      if (cwSum > 0) { shouldReverse = !shouldReverse; }\n      if (isOutside) { shouldReverse = !shouldReverse; }\n      if (shouldReverse) { walls.reverse(); }\n\n      return walls;\n\n    }\n    function getNextWallEl(wallEl) {\n      const wallList = getRoomWallArray(wallEl.parentNode);\n      const curWallIndex = wallList.indexOf(wallEl);\n      return wallList[(curWallIndex + 1) % wallList.length];\n    }\n\n    const worldWallPos = new THREE.Vector3();\n    const worldNextPos = new THREE.Vector3();\n    const worldLinkPos = new THREE.Vector3();\n    function moveForLink(doorholeEl, doorlinkEl) {\n\n      const holeWallEl = doorholeEl.parentNode;\n      const nextWallEl = getNextWallEl(holeWallEl);\n      if (!nextWallEl) { return; }\n\n      holeWallEl.object3D.getWorldPosition(worldWallPos);\n      nextWallEl.object3D.getWorldPosition(worldNextPos);\n      doorlinkEl.object3D.getWorldPosition(worldLinkPos);\n\n      const linkGapX = worldLinkPos.x - worldWallPos.x;\n      const linkGapZ = worldLinkPos.z - worldWallPos.z;\n\n      const wallGapX = worldNextPos.x - worldWallPos.x;\n      const wallGapZ = worldNextPos.z - worldWallPos.z;\n      const wallAng = Math.atan2(wallGapZ, wallGapX);\n      const wallLength = Math.sqrt(wallGapX * wallGapX + wallGapZ * wallGapZ);\n\n      let localLinkX = linkGapX * Math.cos(-wallAng) - linkGapZ * Math.sin(-wallAng);\n      //var localLinkZ = linkGapX*Math.sin(-wallAng) + linkGapZ*Math.cos(-wallAng);\n\n      const doorHalf = doorlinkEl.components.doorlink.data.width / 2;\n      localLinkX = Math.max(localLinkX, doorHalf + HAIR);\n      localLinkX = Math.min(localLinkX, wallLength - doorHalf - HAIR);\n\n      doorholeEl.setAttribute('position', { x: localLinkX, y: 0, z: 0 });\n      doorholeEl.object3D.updateMatrixWorld();\n\n    }\n\n    function getHoleLink(doorholeEl) {\n      const doorlinks = buildingSelf.el.querySelectorAll('[doorlink]');\n      for (let curLinkIndex = 0; curLinkIndex < doorlinks.length; curLinkIndex++) {\n        const curLink = doorlinks[curLinkIndex];\n        if (curLink.components.doorlink.data.from == doorholeEl) { return curLink; }\n        if (curLink.components.doorlink.data.to == doorholeEl) { return curLink; }\n      }\n    }\n\n    function getWallHeight(wallEl) {\n      if (wallEl.components.wall.data.height) { return wallEl.components.wall.data.height; }\n      return wallEl.parentNode.components.room.data.height;\n    }\n\n    if (buildingSelf.dirty) { return; }\n    buildingSelf.dirty = true;\n    setTimeout(() => {\n\n      //console.log(\" == STARTING RE-EVALUATION...\");\n\n      // silly but necessary because of threeJS weirdness\n      buildingSelf.el.object3D.updateMatrixWorld();\n\n      // lay out walls' angles:\n\n      for (var sceneChildNodeIndex = 0; sceneChildNodeIndex < buildingSelf.el.children.length; sceneChildNodeIndex++) {\n        var sceneChildNode = buildingSelf.el.children[sceneChildNodeIndex];\n        if (sceneChildNode.components && sceneChildNode.components.room) {\n\n          const w = sceneChildNode.components.room.data.width;\n          const l = sceneChildNode.components.room.data.length;\n          if (w || l) {\n            if (w && l) {\n              const rawWalls = getUnsortedRoomWallArray(sceneChildNode);\n              if (rawWalls.length >= 4) {\n                if (rawWalls.length > 4) { console.error('rooms with WIDTH and LENGTH should only have four walls!'); }\n                rawWalls[0].setAttribute('position', { x: 0, y: 0, z: 0 });\n                rawWalls[1].setAttribute('position', { x: w, y: 0, z: 0 });\n                rawWalls[2].setAttribute('position', { x: w, y: 0, z: l });\n                rawWalls[3].setAttribute('position', { x: 0, y: 0, z: l });\n              } else {\n                console.error('rooms with WIDTH and LENGTH must have four walls!');\n              }\n            } else {\n              console.error('rooms with WIDTH must also have LENGTH (and vice versa)');\n            }\n          }\n\n          var walls = getRoomWallArray(sceneChildNode);\n          if (walls.length > 2) {\n\n            for (var wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n              var curWallNode = walls[wallIndex];\n              var nextWallNode = walls[(wallIndex + 1) % walls.length];\n\n              var wallGapX = nextWallNode.components.position.data.x - curWallNode.components.position.data.x;\n              var wallGapZ = nextWallNode.components.position.data.z - curWallNode.components.position.data.z;\n              var wallAng = Math.atan2(wallGapZ, wallGapX);\n\n              curWallNode.setAttribute('rotation', { x: 0, y: -wallAng / Math.PI * 180, z: 0 });\n              curWallNode.object3D.updateMatrixWorld();\n            }\n\n          }\n\n        }\n      }\n\n      // position the door holes:\n\n      const doorlinks = buildingSelf.el.querySelectorAll('[doorlink]');\n      for (var curDoorlinkElIndex = 0; curDoorlinkElIndex < doorlinks.length; curDoorlinkElIndex++) {\n        var curDoorlinkEl = doorlinks[curDoorlinkElIndex];\n        var curDoorlink = curDoorlinkEl.components.doorlink;\n        if (!curDoorlink) { return; }//still setting up, try again later\n\n        moveForLink(curDoorlink.data.from, curDoorlink.el);\n        moveForLink(curDoorlink.data.to, curDoorlink.el);\n\n      }\n\n      // generate the walls' geometry:\n\n      for (var sceneChildNodeIndex = 0; sceneChildNodeIndex < buildingSelf.el.children.length; sceneChildNodeIndex++) {\n        var sceneChildNode = buildingSelf.el.children[sceneChildNodeIndex];\n        if (sceneChildNode.components && sceneChildNode.components.room) {\n\n          const isOutside = sceneChildNode.components.room.data.outside;\n          var walls = getRoomWallArray(sceneChildNode);\n\n          if (walls.length > 2) {\n\n            for (var wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n              var curWallNode = walls[wallIndex];\n              var nextWallNode = walls[(wallIndex + 1) % walls.length];\n\n              var wallGapX = nextWallNode.components.position.data.x - curWallNode.components.position.data.x;\n              var wallGapZ = nextWallNode.components.position.data.z - curWallNode.components.position.data.z;\n              const wallLength = Math.sqrt(wallGapX * wallGapX + wallGapZ * wallGapZ);\n              var wallAng = Math.atan2(wallGapZ, wallGapX);\n\n              const wallGapY = nextWallNode.components.position.data.y - curWallNode.components.position.data.y;\n              const heightGap = getWallHeight(nextWallNode) - getWallHeight(curWallNode);\n\n              const orderedHoles = [];\n              for (let wallChildNodeIndex = 0; wallChildNodeIndex < curWallNode.children.length; wallChildNodeIndex++) {\n                const wallChildNode = curWallNode.children[wallChildNodeIndex];\n                if (wallChildNode.components && wallChildNode.components.doorhole) {\n                  orderedHoles.push(wallChildNode);\n                }\n              }\n              orderedHoles.sort((a, b) => {\n                return a.components.position.data.x - b.components.position.data.x;\n              });\n\n              const wallShape = new THREE.Shape();\n              wallShape.moveTo(\n                0,\n                getWallHeight(curWallNode)\n              );\n              wallShape.lineTo(\n                0,\n                0\n              );\n\n              for (let holeIndex = 0; holeIndex < orderedHoles.length; holeIndex++) {\n\n                var holeEl = orderedHoles[holeIndex];\n                if (!holeEl.myVerts) { holeEl.myVerts = []; }\n                holeEl.myVerts.length = 0;\n\n                const linkEl = getHoleLink(orderedHoles[holeIndex]);\n                if (!linkEl) { continue; }\n\n                const holeInfo = holeEl.components;\n                const linkInfo = linkEl.components;\n\n                for (let holeSide = -1; holeSide <= 1; holeSide += 2) {\n                  var ptX = holeInfo.position.data.x + linkInfo.doorlink.data.width / 2 * holeSide;\n                  const floorY = (ptX / wallLength) * wallGapY;\n                  let topY = floorY + linkInfo.doorlink.data.height;\n\n                  const curCeil = getWallHeight(curWallNode) + (ptX / wallLength) * heightGap;\n                  const maxTopY = floorY + curCeil - HAIR;//will always be a seam, but, I'm not bothering to rewrite just for that\n                  if (topY > maxTopY) { topY = maxTopY; }\n\n                  function addWorldVert(ptY) {\n                    const tempPos = new THREE.Vector3(ptX, ptY, 0);\n                    curWallNode.object3D.localToWorld(tempPos);\n                    holeEl.myVerts.push(tempPos);\n                  }\n                  addWorldVert(floorY);\n                  addWorldVert(topY);\n\n                  if (holeSide < 0) {\n                    wallShape.lineTo(ptX, floorY);\n                    wallShape.lineTo(ptX, topY);\n                  } else {\n                    wallShape.lineTo(ptX, topY);\n                    wallShape.lineTo(ptX, floorY);\n                  }\n                }\n\n              }\n\n              wallShape.lineTo(\n                wallLength,\n                nextWallNode.components.position.data.y - curWallNode.components.position.data.y\n              );\n              wallShape.lineTo(\n                wallLength,\n                (nextWallNode.components.position.data.y - curWallNode.components.position.data.y) + getWallHeight(nextWallNode)\n              );\n\n              const wallGeom = new THREE.ShapeGeometry(wallShape);\n              makePlaneUvs(wallGeom, 'x', 'y', 1, 1);\n              finishGeom(wallGeom);\n              var myMat = curWallNode.components.material ? curWallNode.components.material.material : curWallNode.parentNode.components.material.material;\n              if (curWallNode.myMesh) {\n                curWallNode.myMesh.geometry = wallGeom;\n                curWallNode.myMesh.material = myMat;\n              } else {\n                curWallNode.myMesh = new THREE.Mesh(wallGeom, myMat);\n                curWallNode.setObject3D('wallMesh', curWallNode.myMesh);\n              }\n\n            }\n\n            const caps = [];\n            for (let roomChildNodeIndex = 0; roomChildNodeIndex < sceneChildNode.children.length; roomChildNodeIndex++) {\n              const roomChildNode = sceneChildNode.children[roomChildNodeIndex];\n              if (roomChildNode.components) {\n                if (roomChildNode.components.floor || roomChildNode.components.ceiling) { caps.push(roomChildNode); }\n              }\n            }\n            for (let curCapNodeIndex = 0; curCapNodeIndex < caps.length; curCapNodeIndex++) {\n              const curCapNode = caps[curCapNodeIndex];\n              const isCeiling = curCapNode.components.ceiling;\n\n              const capShape = new THREE.Shape();\n              for (var wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n                var curWallNode = walls[wallIndex];\n                var ptX = curWallNode.components.position.data.x;\n                const ptZ = curWallNode.components.position.data.z;\n                if (wallIndex) {\n                  capShape.lineTo(ptX, ptZ);\n                } else {\n                  capShape.moveTo(ptX, ptZ);\n                }\n              }\n              const capGeom = new THREE.ShapeGeometry(capShape);\n              for (var wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n                var curWallNode = walls[wallIndex];\n                const curVert = new THREE.Vector3(\n                  capGeom.attributes.position.getX(wallIndex),\n                  capGeom.attributes.position.getY(wallIndex),\n                  capGeom.attributes.position.getZ(wallIndex)\n                );\n                curVert.set(curVert.x, curWallNode.components.position.data.y, curVert.y);\n                if (isCeiling) { curVert.y += getWallHeight(curWallNode); }\n                capGeom.attributes.position.setXYZ(wallIndex, curVert.x, curVert.y, curVert.z);\n              }\n\n              let shouldReverse = false;\n              if (!isCeiling) { shouldReverse = !shouldReverse; }\n              if (isOutside) { shouldReverse = !shouldReverse; }\n              if (shouldReverse) { flipGeom(capGeom); }\n\n              makePlaneUvs(capGeom, 'x', 'z', isCeiling ? 1 : -1, 1);\n              finishGeom(capGeom);\n\n              if (!curCapNode.myMeshes) { curCapNode.myMeshes = []; }\n\n              const typeLabel = isCeiling ? 'ceiling' : 'floor';\n              var myMat = curCapNode.components.material ? curCapNode.components.material.material : curCapNode.parentNode.components.material.material;\n              if (curCapNode.myMeshes[typeLabel]) {\n                curCapNode.myMeshes[typeLabel].geometry = capGeom;\n                curCapNode.myMeshes[typeLabel].material = myMat;\n              } else {\n                curCapNode.myMeshes[typeLabel] = new THREE.Mesh(capGeom, myMat);\n                curCapNode.setObject3D(typeLabel, curCapNode.myMeshes[typeLabel]);\n              }\n\n            }\n\n          }\n\n        }\n      }\n\n      // generate the door tunnels' geometry:\n\n      for (var curDoorlinkElIndex = 0; curDoorlinkElIndex < doorlinks.length; curDoorlinkElIndex++) {\n        var curDoorlinkEl = doorlinks[curDoorlinkElIndex];\n\n        var curDoorlink = curDoorlinkEl.components.doorlink;\n        if (!curDoorlink.data.from) { continue; }\n        if (!curDoorlink.data.to) { continue; }\n        if (!curDoorlink.data.from.myVerts) { return; }\n        if (!curDoorlink.data.to.myVerts) { return; }\n\n        for (let doorLinkChildIndex = 0; doorLinkChildIndex < curDoorlinkEl.children.length; doorLinkChildIndex++) {\n          var doorLinkChild = curDoorlinkEl.children[doorLinkChildIndex];\n          if (!doorLinkChild.components) { continue; }\n\n          const types = ['sides', 'floor', 'ceiling'];\n          for (let curTypeIndex = 0; curTypeIndex < types.length; curTypeIndex++) {\n            const curType = types[curTypeIndex];\n\n            if (!doorLinkChild.components[curType]) { continue; }\n\n            var myMat = doorLinkChild.components.material ? doorLinkChild.components.material.material : doorLinkChild.parentNode.components.material.material;\n\n            if (!doorLinkChild.myGeoms) { doorLinkChild.myGeoms = []; }\n            if (!doorLinkChild.myGeoms[curType]) {\n              var curGeom = new THREE.BufferGeometry();\n              doorLinkChild.myGeoms[curType] = curGeom;\n              const myMesh = new THREE.Mesh(\n                curGeom,\n                myMat\n              );\n              curGeom.meshRef = myMesh;\n              doorLinkChild.setObject3D(curType, myMesh);\n              const indexArray = [];\n              indexArray.push(0, 1, 2, 1, 3, 2);\n              if (curType == 'sides') { indexArray.push(4, 5, 6, 5, 7, 6); }\n              curGeom.setIndex(indexArray);\n            }\n\n            var curGeom = doorLinkChild.myGeoms[curType];\n            curGeom.meshRef.material = myMat;\n            var positionArray = [];\n            function addWorldVertex(pt) {\n              const localPt = pt.clone();\n              doorLinkChild.object3D.worldToLocal(localPt);\n              positionArray.push(localPt.x, localPt.y, localPt.z);\n            }\n            function commitVertices() {\n              curGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positionArray), 3));\n            }\n            const fVerts = curDoorlink.data.from.myVerts;\n            const tVerts = curDoorlink.data.to.myVerts;\n            switch (curType) {\n              case 'floor':\n\n                addWorldVertex(tVerts[0]);\n                addWorldVertex(tVerts[2]);\n                addWorldVertex(fVerts[2]);\n                addWorldVertex(fVerts[0]);\n\n                commitVertices();\n\n                makeUvsForGeom(curGeom, (pt, vertIndex) => {\n                  return [\n                    1 - (vertIndex % 2),\n                    1 - Math.floor(vertIndex / 2)\n                  ];\n                });\n\n                break;\n              case 'ceiling':\n\n                addWorldVertex(tVerts[3]);\n                addWorldVertex(tVerts[1]);\n                addWorldVertex(fVerts[1]);\n                addWorldVertex(fVerts[3]);\n\n                commitVertices();\n\n                makeUvsForGeom(curGeom, (pt, vertIndex) => {\n                  return [\n                    vertIndex % 2,\n                    1 - Math.floor(vertIndex / 2)\n                  ];\n                });\n\n                break;\n              case 'sides':\n\n                addWorldVertex(tVerts[2]);\n                addWorldVertex(tVerts[3]);\n                addWorldVertex(fVerts[0]);\n                addWorldVertex(fVerts[1]);\n\n                addWorldVertex(fVerts[2]);\n                addWorldVertex(fVerts[3]);\n                addWorldVertex(tVerts[0]);\n                addWorldVertex(tVerts[1]);\n\n                commitVertices();\n\n                makeUvsForGeom(curGeom, (pt, vertIndex) => {\n                  const uv = [];\n                  uv[0] = Math.floor(vertIndex / 2);\n                  uv[1] = vertIndex % 2;\n                  if (vertIndex < 4) { uv[0] = 1 - uv[0]; }\n                  return uv;\n                });\n\n                break;\n            }\n            finishGeom(curGeom);\n\n          }\n        }\n\n      }\n\n      //console.log(\" === RE-EVALUATION COMPLETE!\");\n      buildingSelf.dirty = false;\n\n    });\n\n  }\n\n});\n\nfunction updateScene(lastScene) {\n  if (lastScene && lastScene.systems.building) { lastScene.systems.building.reexamineBuilding(); }\n}\nfunction positionWatch(e) {\n  if (e.detail.name == 'position') { updateScene(e.detail.target.sceneEl); }\n}\n\nfunction nodeSceneInit() {\n  this.lastScene = this.el.sceneEl;\n  updateScene(this.lastScene);\n  this.el.addEventListener('componentchanged', positionWatch);\n}\nfunction nodeSceneUpdate() {\n  updateScene(this.lastScene);\n}\nfunction nodeSceneRemove() {\n  updateScene(this.lastScene);\n  this.lastScene = null;\n  this.el.removeEventListener('componentchanged', positionWatch);\n}\n\nconst refreshSceneConfig = {\n  init: nodeSceneInit,\n  update: nodeSceneUpdate,\n  remove: nodeSceneRemove\n};\n\nAFRAME.registerComponent('room', Object.assign({\n\n  schema: {\n    outside: { type: 'boolean' },\n    height: { type: 'number', default: 2.4 },\n    width: { type: 'number' },\n    length: { type: 'number' }\n  }\n\n}, refreshSceneConfig));\n\nAFRAME.registerComponent('wall', Object.assign({\n\n  schema: {\n    height: { type: 'number' }\n  }\n\n}, refreshSceneConfig));\n\nAFRAME.registerComponent('floor', refreshSceneConfig);\nAFRAME.registerComponent('ceiling', refreshSceneConfig);\n\nAFRAME.registerComponent('doorhole', refreshSceneConfig);\n\nAFRAME.registerComponent('doorlink', Object.assign({\n\n  schema: {\n    from: { type: 'selector' },\n    to: { type: 'selector' },\n    height: { type: 'number', default: 2.0 },\n    width: { type: 'number', default: 0.8 }\n  }\n\n}, refreshSceneConfig));\n\nAFRAME.registerComponent('sides', refreshSceneConfig);\n\n// could probably automate this rather than hard-coding it, but this'll do for now:\n\nAFRAME.registerPrimitive('rw-room', {\n  defaultComponents: { room: {} },\n  mappings: {\n    outside: 'room.outside',\n    height: 'room.height',\n    width: 'room.width',\n    length: 'room.length'\n  }\n});\n\nAFRAME.registerPrimitive('rw-wall', {\n  defaultComponents: { wall: {} },\n  mappings: {\n    height: 'wall.height'\n  }\n});\n\nAFRAME.registerPrimitive('rw-floor', {\n  defaultComponents: { floor: {} },\n  mappings: {}\n});\n\nAFRAME.registerPrimitive('rw-ceiling', {\n  defaultComponents: { ceiling: {} },\n  mappings: {}\n});\n\nAFRAME.registerPrimitive('rw-doorhole', {\n  defaultComponents: { doorhole: {} },\n  mappings: {}\n});\n\nAFRAME.registerPrimitive('rw-doorlink', {\n  defaultComponents: { doorlink: {} },\n  mappings: {\n    from: 'doorlink.from',\n    to: 'doorlink.to',\n    height: 'doorlink.height',\n    width: 'doorlink.width'\n  }\n});\n\nAFRAME.registerPrimitive('rw-sides', {\n  defaultComponents: { sides: {} },\n  mappings: {}\n});\n\n\n//# sourceURL=webpack://aframe-room-component/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"]();
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});