/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (() => {

eval("\n\nAFRAME.registerSystem('building', {\n\n  reexamineBuilding: function () {\n    // console.log(\" = REEVALUATION REQUESTED...\");\n\n    const buildingSelf = this;\n    const HAIR = 0.0001;\n\n    /*\n\n    https://github.com/oparamo/aframe-room-component\n    v0.5.0\n\n    OPTIMIZATION:\n\n    currently, the entire building is getting re-generated from scratch any time anything in it changes.\n    obviously this is wasteful, but:\n    - this library isn't particularly likely to be used in a context where these properties will be changing at runtime (at least outside of debugging)\n    - right now I am more concerned with getting it out the door than making it perfect anyway\n\n    PLANNED FEATURES TO COME (in order):\n    - greater control over UV generation\n    - automatic collision assignment\n    - doors lifted above the ground (i.e. windows)\n    - accept a shape to be extruded around a doorhole to make a doorframe (& around a floor to make a baseboard)\n\n    KNOWN ISSUES (with no obvious solution that would preserve ease of use):\n    - floor/ceiling triangulation is not controllable (and therefore varying wall verticality is nearly useless unless slope is consistent)\n    - doorhole parenting is always level to the horizon even on slope-floored walls\n    - the setTimeout thing results in a one-frame flash of invisible walls: is it worth it? (is there a smarter thing to listen for, maybe?)\n\n    ISSUES THAT COULD THEORETICALLY BE FIXED BUT DON'T SEEM WORTH THE TROUBLE:\n    - walls are internally rearranged to always wind CW, which means wall parenting will point towards the \"previous\" wall if you entered them in CCW order\n\n    */\n\n    function flipGeom (geom) {\n      const indexCopy = geom.index;\n      for (let curFaceIndex = 0; curFaceIndex < indexCopy.count / 3; curFaceIndex++) {\n        const bucket = indexCopy[curFaceIndex * 3 + 2];\n        indexCopy[curFaceIndex * 3 + 2] = indexCopy[curFaceIndex * 3 + 1];\n        indexCopy[curFaceIndex * 3 + 1] = bucket;\n      }\n      geom.setIndex(indexCopy);\n    }\n\n    function makeUvsForGeom (geom, callback) {\n      const allUVs = [];\n      for (let faceVertIndex = 0; faceVertIndex < geom.index.array.length; faceVertIndex++) {\n        const vertexIndex = geom.index.array[faceVertIndex];\n        const vertex = new THREE.Vector3(\n          geom.attributes.position.getX(vertexIndex),\n          geom.attributes.position.getY(vertexIndex),\n          geom.attributes.position.getZ(vertexIndex)\n        );\n        const uv = callback(vertex, faceVertIndex % 3);\n        allUVs[vertexIndex * 2 + 0] = uv[0];\n        allUVs[vertexIndex * 2 + 1] = uv[1];\n      }\n      geom.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(allUVs), 2));\n      geom.uvsNeedUpdate = true;\n    }\n    function makePlaneUvs (geom, uKey, vKey, uMult, vMult) {\n      makeUvsForGeom(geom, (pt) => {\n        return [\n          pt[uKey] * uMult,\n          pt[vKey] * vMult\n        ];\n      });\n    }\n\n    function finishGeom (geom) {\n      geom.computeVertexNormals();\n      // are these necessary?\n      geom.computeBoundingBox();\n      geom.computeBoundingSphere();\n    }\n\n    function getUnsortedRoomWallArray (roomEl) {\n      const walls = [];\n      for (let roomChildNodeIndex = 0; roomChildNodeIndex < roomEl.children.length; roomChildNodeIndex++) {\n        const roomChildNode = roomEl.children[roomChildNodeIndex];\n        if (roomChildNode.components.wall) { walls.push(roomChildNode); }\n      }\n      return walls;\n    }\n\n    function getRoomWallArray (roomEl) {\n      // the results of this not being saved anywhere is super wasteful,\n      // but, see above; not worth worrying about yet\n\n      const isOutside = roomEl.components.room.data.outside;\n\n      const walls = getUnsortedRoomWallArray(roomEl);\n\n      let cwSum = 0;\n      for (let wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n        const curWallNode = walls[wallIndex];\n        const nextWallNode = walls[(wallIndex + 1) % walls.length];\n        const curWallPos = curWallNode.components.position.data;\n        const nextWallPos = nextWallNode.components.position.data;\n\n        cwSum += (nextWallPos.x - curWallPos.x) * (nextWallPos.z + curWallPos.z);\n      }\n\n      let shouldReverse = false;\n      if (cwSum > 0) { shouldReverse = !shouldReverse; }\n      if (isOutside) { shouldReverse = !shouldReverse; }\n      if (shouldReverse) { walls.reverse(); }\n\n      return walls;\n    }\n    function getNextWallEl (wallEl) {\n      const wallList = getRoomWallArray(wallEl.parentNode);\n      const curWallIndex = wallList.indexOf(wallEl);\n      return wallList[(curWallIndex + 1) % wallList.length];\n    }\n\n    const worldWallPos = new THREE.Vector3();\n    const worldNextPos = new THREE.Vector3();\n    const worldLinkPos = new THREE.Vector3();\n    function moveForLink (doorholeEl, doorlinkEl) {\n      const holeWallEl = doorholeEl.parentNode;\n      const nextWallEl = getNextWallEl(holeWallEl);\n      if (!nextWallEl) { return; }\n\n      holeWallEl.object3D.getWorldPosition(worldWallPos);\n      nextWallEl.object3D.getWorldPosition(worldNextPos);\n      doorlinkEl.object3D.getWorldPosition(worldLinkPos);\n\n      const linkGapX = worldLinkPos.x - worldWallPos.x;\n      const linkGapZ = worldLinkPos.z - worldWallPos.z;\n\n      const wallGapX = worldNextPos.x - worldWallPos.x;\n      const wallGapZ = worldNextPos.z - worldWallPos.z;\n      const wallAng = Math.atan2(wallGapZ, wallGapX);\n      const wallLength = Math.sqrt(wallGapX * wallGapX + wallGapZ * wallGapZ);\n\n      let localLinkX = linkGapX * Math.cos(-wallAng) - linkGapZ * Math.sin(-wallAng);\n      // var localLinkZ = linkGapX*Math.sin(-wallAng) + linkGapZ*Math.cos(-wallAng);\n\n      const doorHalf = doorlinkEl.components.doorlink.data.width / 2;\n      localLinkX = Math.max(localLinkX, doorHalf + HAIR);\n      localLinkX = Math.min(localLinkX, wallLength - doorHalf - HAIR);\n\n      doorholeEl.setAttribute('position', { x: localLinkX, y: 0, z: 0 });\n      doorholeEl.object3D.updateMatrixWorld();\n    }\n\n    function getHoleLink (doorholeEl) {\n      const doorlinks = buildingSelf.el.querySelectorAll('[doorlink]');\n      for (let curLinkIndex = 0; curLinkIndex < doorlinks.length; curLinkIndex++) {\n        const curLink = doorlinks[curLinkIndex];\n        if (curLink.components.doorlink.data.from === doorholeEl) { return curLink; }\n        if (curLink.components.doorlink.data.to === doorholeEl) { return curLink; }\n      }\n    }\n\n    function getWallHeight (wallEl) {\n      if (wallEl.components.wall.data.height) { return wallEl.components.wall.data.height; }\n      return wallEl.parentNode.components.room.data.height;\n    }\n\n    if (buildingSelf.dirty) { return; }\n    buildingSelf.dirty = true;\n    setTimeout(() => {\n      // console.log(\" == STARTING RE-EVALUATION...\");\n\n      // silly but necessary because of threeJS weirdness\n      buildingSelf.el.object3D.updateMatrixWorld();\n\n      // lay out walls' angles:\n\n      for (let sceneChildNodeIndex = 0; sceneChildNodeIndex < buildingSelf.el.children.length; sceneChildNodeIndex++) {\n        const sceneChildNode = buildingSelf.el.children[sceneChildNodeIndex];\n        if (sceneChildNode.components && sceneChildNode.components.room) {\n          const w = sceneChildNode.components.room.data.width;\n          const l = sceneChildNode.components.room.data.length;\n          if (w || l) {\n            if (w && l) {\n              const rawWalls = getUnsortedRoomWallArray(sceneChildNode);\n              if (rawWalls.length >= 4) {\n                if (rawWalls.length > 4) { console.error('rooms with WIDTH and LENGTH should only have four walls!'); }\n                rawWalls[0].setAttribute('position', { x: 0, y: 0, z: 0 });\n                rawWalls[1].setAttribute('position', { x: w, y: 0, z: 0 });\n                rawWalls[2].setAttribute('position', { x: w, y: 0, z: l });\n                rawWalls[3].setAttribute('position', { x: 0, y: 0, z: l });\n              } else {\n                console.error('rooms with WIDTH and LENGTH must have four walls!');\n              }\n            } else {\n              console.error('rooms with WIDTH must also have LENGTH (and vice versa)');\n            }\n          }\n\n          const walls = getRoomWallArray(sceneChildNode);\n          if (walls.length > 2) {\n            for (let wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n              const curWallNode = walls[wallIndex];\n              const nextWallNode = walls[(wallIndex + 1) % walls.length];\n\n              const wallGapX = nextWallNode.components.position.data.x - curWallNode.components.position.data.x;\n              const wallGapZ = nextWallNode.components.position.data.z - curWallNode.components.position.data.z;\n              const wallAng = Math.atan2(wallGapZ, wallGapX);\n\n              curWallNode.setAttribute('rotation', { x: 0, y: -wallAng / Math.PI * 180, z: 0 });\n              curWallNode.object3D.updateMatrixWorld();\n            }\n          }\n        }\n      }\n\n      // position the door holes:\n\n      const doorlinks = buildingSelf.el.querySelectorAll('[doorlink]');\n      for (let curDoorlinkElIndex = 0; curDoorlinkElIndex < doorlinks.length; curDoorlinkElIndex++) {\n        const curDoorlinkEl = doorlinks[curDoorlinkElIndex];\n        const curDoorlink = curDoorlinkEl.components.doorlink;\n        if (!curDoorlink) { return; }// still setting up, try again later\n\n        moveForLink(curDoorlink.data.from, curDoorlink.el);\n        moveForLink(curDoorlink.data.to, curDoorlink.el);\n      }\n\n      // generate the walls' geometry:\n\n      for (let sceneChildNodeIndex = 0; sceneChildNodeIndex < buildingSelf.el.children.length; sceneChildNodeIndex++) {\n        const sceneChildNode = buildingSelf.el.children[sceneChildNodeIndex];\n        if (sceneChildNode.components && sceneChildNode.components.room) {\n          const isOutside = sceneChildNode.components.room.data.outside;\n          const walls = getRoomWallArray(sceneChildNode);\n\n          if (walls.length > 2) {\n            for (let wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n              const curWallNode = walls[wallIndex];\n              const nextWallNode = walls[(wallIndex + 1) % walls.length];\n\n              const wallGapX = nextWallNode.components.position.data.x - curWallNode.components.position.data.x;\n              const wallGapZ = nextWallNode.components.position.data.z - curWallNode.components.position.data.z;\n              const wallLength = Math.sqrt(wallGapX * wallGapX + wallGapZ * wallGapZ);\n              // var wallAng = Math.atan2(wallGapZ, wallGapX);\n\n              const wallGapY = nextWallNode.components.position.data.y - curWallNode.components.position.data.y;\n              const heightGap = getWallHeight(nextWallNode) - getWallHeight(curWallNode);\n\n              const orderedHoles = [];\n              for (let wallChildNodeIndex = 0; wallChildNodeIndex < curWallNode.children.length; wallChildNodeIndex++) {\n                const wallChildNode = curWallNode.children[wallChildNodeIndex];\n                if (wallChildNode.components && wallChildNode.components.doorhole) {\n                  orderedHoles.push(wallChildNode);\n                }\n              }\n              orderedHoles.sort((a, b) => {\n                return a.components.position.data.x - b.components.position.data.x;\n              });\n\n              const wallShape = new THREE.Shape();\n              wallShape.moveTo(\n                0,\n                getWallHeight(curWallNode)\n              );\n              wallShape.lineTo(\n                0,\n                0\n              );\n\n              for (let holeIndex = 0; holeIndex < orderedHoles.length; holeIndex++) {\n                const holeEl = orderedHoles[holeIndex];\n                if (!holeEl.myVerts) { holeEl.myVerts = []; }\n                holeEl.myVerts.length = 0;\n\n                const linkEl = getHoleLink(orderedHoles[holeIndex]);\n                if (!linkEl) { continue; }\n\n                const holeInfo = holeEl.components;\n                const linkInfo = linkEl.components;\n\n                for (let holeSide = -1; holeSide <= 1; holeSide += 2) {\n                  const ptX = holeInfo.position.data.x + linkInfo.doorlink.data.width / 2 * holeSide;\n                  const floorY = (ptX / wallLength) * wallGapY;\n                  let topY = floorY + linkInfo.doorlink.data.height;\n\n                  const curCeil = getWallHeight(curWallNode) + (ptX / wallLength) * heightGap;\n                  const maxTopY = floorY + curCeil - HAIR;// will always be a seam, but, I'm not bothering to rewrite just for that\n                  if (topY > maxTopY) { topY = maxTopY; }\n\n                  function addWorldVert (ptY) {\n                    const tempPos = new THREE.Vector3(ptX, ptY, 0);\n                    curWallNode.object3D.localToWorld(tempPos);\n                    holeEl.myVerts.push(tempPos);\n                  }\n                  addWorldVert(floorY);\n                  addWorldVert(topY);\n\n                  if (holeSide < 0) {\n                    wallShape.lineTo(ptX, floorY);\n                    wallShape.lineTo(ptX, topY);\n                  } else {\n                    wallShape.lineTo(ptX, topY);\n                    wallShape.lineTo(ptX, floorY);\n                  }\n                }\n              }\n\n              wallShape.lineTo(\n                wallLength,\n                nextWallNode.components.position.data.y - curWallNode.components.position.data.y\n              );\n              wallShape.lineTo(\n                wallLength,\n                (nextWallNode.components.position.data.y - curWallNode.components.position.data.y) + getWallHeight(nextWallNode)\n              );\n\n              const wallGeom = new THREE.ShapeGeometry(wallShape);\n              makePlaneUvs(wallGeom, 'x', 'y', 1, 1);\n              finishGeom(wallGeom);\n              const myMat = curWallNode.components.material ? curWallNode.components.material.material : curWallNode.parentNode.components.material.material;\n              if (curWallNode.myMesh) {\n                curWallNode.myMesh.geometry = wallGeom;\n                curWallNode.myMesh.material = myMat;\n              } else {\n                curWallNode.myMesh = new THREE.Mesh(wallGeom, myMat);\n                curWallNode.setObject3D('wallMesh', curWallNode.myMesh);\n              }\n            }\n\n            const caps = [];\n            for (let roomChildNodeIndex = 0; roomChildNodeIndex < sceneChildNode.children.length; roomChildNodeIndex++) {\n              const roomChildNode = sceneChildNode.children[roomChildNodeIndex];\n              if (roomChildNode.components) {\n                if (roomChildNode.components.floor || roomChildNode.components.ceiling) { caps.push(roomChildNode); }\n              }\n            }\n            for (let curCapNodeIndex = 0; curCapNodeIndex < caps.length; curCapNodeIndex++) {\n              const curCapNode = caps[curCapNodeIndex];\n              const isCeiling = curCapNode.components.ceiling;\n\n              const capShape = new THREE.Shape();\n              for (let wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n                const curWallNode = walls[wallIndex];\n                const ptX = curWallNode.components.position.data.x;\n                const ptZ = curWallNode.components.position.data.z;\n                if (wallIndex) {\n                  capShape.lineTo(ptX, ptZ);\n                } else {\n                  capShape.moveTo(ptX, ptZ);\n                }\n              }\n              const capGeom = new THREE.ShapeGeometry(capShape);\n              for (let wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n                const curWallNode = walls[wallIndex];\n                const curVert = new THREE.Vector3(\n                  capGeom.attributes.position.getX(wallIndex),\n                  capGeom.attributes.position.getY(wallIndex),\n                  capGeom.attributes.position.getZ(wallIndex)\n                );\n                curVert.set(curVert.x, curWallNode.components.position.data.y, curVert.y);\n                if (isCeiling) { curVert.y += getWallHeight(curWallNode); }\n                capGeom.attributes.position.setXYZ(wallIndex, curVert.x, curVert.y, curVert.z);\n              }\n\n              let shouldReverse = false;\n              if (!isCeiling) { shouldReverse = !shouldReverse; }\n              if (isOutside) { shouldReverse = !shouldReverse; }\n              if (shouldReverse) { flipGeom(capGeom); }\n\n              makePlaneUvs(capGeom, 'x', 'z', isCeiling ? 1 : -1, 1);\n              finishGeom(capGeom);\n\n              if (!curCapNode.myMeshes) { curCapNode.myMeshes = []; }\n\n              const typeLabel = isCeiling ? 'ceiling' : 'floor';\n              const myMat = curCapNode.components.material ? curCapNode.components.material.material : curCapNode.parentNode.components.material.material;\n              if (curCapNode.myMeshes[typeLabel]) {\n                curCapNode.myMeshes[typeLabel].geometry = capGeom;\n                curCapNode.myMeshes[typeLabel].material = myMat;\n              } else {\n                curCapNode.myMeshes[typeLabel] = new THREE.Mesh(capGeom, myMat);\n                curCapNode.setObject3D(typeLabel, curCapNode.myMeshes[typeLabel]);\n              }\n            }\n          }\n        }\n      }\n\n      // generate the door tunnels' geometry:\n\n      for (let curDoorlinkElIndex = 0; curDoorlinkElIndex < doorlinks.length; curDoorlinkElIndex++) {\n        const curDoorlinkEl = doorlinks[curDoorlinkElIndex];\n\n        const curDoorlink = curDoorlinkEl.components.doorlink;\n        if (!curDoorlink.data.from) { continue; }\n        if (!curDoorlink.data.to) { continue; }\n        if (!curDoorlink.data.from.myVerts) { return; }\n        if (!curDoorlink.data.to.myVerts) { return; }\n\n        for (let doorLinkChildIndex = 0; doorLinkChildIndex < curDoorlinkEl.children.length; doorLinkChildIndex++) {\n          const doorLinkChild = curDoorlinkEl.children[doorLinkChildIndex];\n          if (!doorLinkChild.components) { continue; }\n\n          const types = ['sides', 'floor', 'ceiling'];\n          for (let curTypeIndex = 0; curTypeIndex < types.length; curTypeIndex++) {\n            const curType = types[curTypeIndex];\n\n            if (!doorLinkChild.components[curType]) { continue; }\n\n            const myMat = doorLinkChild.components.material ? doorLinkChild.components.material.material : doorLinkChild.parentNode.components.material.material;\n\n            if (!doorLinkChild.myGeoms) { doorLinkChild.myGeoms = []; }\n            if (!doorLinkChild.myGeoms[curType]) {\n              const curGeom = new THREE.BufferGeometry();\n              doorLinkChild.myGeoms[curType] = curGeom;\n              const myMesh = new THREE.Mesh(\n                curGeom,\n                myMat\n              );\n              curGeom.meshRef = myMesh;\n              doorLinkChild.setObject3D(curType, myMesh);\n              const indexArray = [];\n              indexArray.push(0, 1, 2, 1, 3, 2);\n              if (curType === 'sides') { indexArray.push(4, 5, 6, 5, 7, 6); }\n              curGeom.setIndex(indexArray);\n            }\n\n            const curGeom = doorLinkChild.myGeoms[curType];\n            curGeom.meshRef.material = myMat;\n            const positionArray = [];\n            function addWorldVertex (pt) {\n              const localPt = pt.clone();\n              doorLinkChild.object3D.worldToLocal(localPt);\n              positionArray.push(localPt.x, localPt.y, localPt.z);\n            }\n            function commitVertices () {\n              curGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positionArray), 3));\n            }\n            const fVerts = curDoorlink.data.from.myVerts;\n            const tVerts = curDoorlink.data.to.myVerts;\n            switch (curType) {\n              case 'floor':\n\n                addWorldVertex(tVerts[0]);\n                addWorldVertex(tVerts[2]);\n                addWorldVertex(fVerts[2]);\n                addWorldVertex(fVerts[0]);\n\n                commitVertices();\n\n                makeUvsForGeom(curGeom, (pt, vertIndex) => {\n                  return [\n                    1 - (vertIndex % 2),\n                    1 - Math.floor(vertIndex / 2)\n                  ];\n                });\n\n                break;\n              case 'ceiling':\n\n                addWorldVertex(tVerts[3]);\n                addWorldVertex(tVerts[1]);\n                addWorldVertex(fVerts[1]);\n                addWorldVertex(fVerts[3]);\n\n                commitVertices();\n\n                makeUvsForGeom(curGeom, (pt, vertIndex) => {\n                  return [\n                    vertIndex % 2,\n                    1 - Math.floor(vertIndex / 2)\n                  ];\n                });\n\n                break;\n              case 'sides':\n\n                addWorldVertex(tVerts[2]);\n                addWorldVertex(tVerts[3]);\n                addWorldVertex(fVerts[0]);\n                addWorldVertex(fVerts[1]);\n\n                addWorldVertex(fVerts[2]);\n                addWorldVertex(fVerts[3]);\n                addWorldVertex(tVerts[0]);\n                addWorldVertex(tVerts[1]);\n\n                commitVertices();\n\n                makeUvsForGeom(curGeom, (pt, vertIndex) => {\n                  const uv = [];\n                  uv[0] = Math.floor(vertIndex / 2);\n                  uv[1] = vertIndex % 2;\n                  if (vertIndex < 4) { uv[0] = 1 - uv[0]; }\n                  return uv;\n                });\n\n                break;\n            }\n            finishGeom(curGeom);\n          }\n        }\n      }\n\n      // console.log(\" === RE-EVALUATION COMPLETE!\");\n      buildingSelf.dirty = false;\n    });\n  }\n\n});\n\nfunction updateScene (lastScene) {\n  if (lastScene && lastScene.systems.building) { lastScene.systems.building.reexamineBuilding(); }\n}\nfunction positionWatch (e) {\n  if (e.detail.name === 'position') { updateScene(e.detail.target.sceneEl); }\n}\n\nfunction nodeSceneInit () {\n  this.lastScene = this.el.sceneEl;\n  updateScene(this.lastScene);\n  this.el.addEventListener('componentchanged', positionWatch);\n}\nfunction nodeSceneUpdate () {\n  updateScene(this.lastScene);\n}\nfunction nodeSceneRemove () {\n  updateScene(this.lastScene);\n  this.lastScene = null;\n  this.el.removeEventListener('componentchanged', positionWatch);\n}\n\nconst refreshSceneConfig = {\n  init: nodeSceneInit,\n  update: nodeSceneUpdate,\n  remove: nodeSceneRemove\n};\n\nAFRAME.registerComponent('room', Object.assign({\n\n  schema: {\n    outside: { type: 'boolean' },\n    height: { type: 'number', default: 2.4 },\n    width: { type: 'number' },\n    length: { type: 'number' }\n  }\n\n}, refreshSceneConfig));\n\nAFRAME.registerComponent('wall', Object.assign({\n\n  schema: {\n    height: { type: 'number' }\n  }\n\n}, refreshSceneConfig));\n\nAFRAME.registerComponent('floor', refreshSceneConfig);\nAFRAME.registerComponent('ceiling', refreshSceneConfig);\n\nAFRAME.registerComponent('doorhole', refreshSceneConfig);\n\nAFRAME.registerComponent('doorlink', Object.assign({\n\n  schema: {\n    from: { type: 'selector' },\n    to: { type: 'selector' },\n    height: { type: 'number', default: 2.0 },\n    width: { type: 'number', default: 0.8 }\n  }\n\n}, refreshSceneConfig));\n\nAFRAME.registerComponent('sides', refreshSceneConfig);\n\n// could probably automate this rather than hard-coding it, but this'll do for now:\n\nAFRAME.registerPrimitive('rw-room', {\n  defaultComponents: { room: {} },\n  mappings: {\n    outside: 'room.outside',\n    height: 'room.height',\n    width: 'room.width',\n    length: 'room.length'\n  }\n});\n\nAFRAME.registerPrimitive('rw-wall', {\n  defaultComponents: { wall: {} },\n  mappings: {\n    height: 'wall.height'\n  }\n});\n\nAFRAME.registerPrimitive('rw-floor', {\n  defaultComponents: { floor: {} },\n  mappings: {}\n});\n\nAFRAME.registerPrimitive('rw-ceiling', {\n  defaultComponents: { ceiling: {} },\n  mappings: {}\n});\n\nAFRAME.registerPrimitive('rw-doorhole', {\n  defaultComponents: { doorhole: {} },\n  mappings: {}\n});\n\nAFRAME.registerPrimitive('rw-doorlink', {\n  defaultComponents: { doorlink: {} },\n  mappings: {\n    from: 'doorlink.from',\n    to: 'doorlink.to',\n    height: 'doorlink.height',\n    width: 'doorlink.width'\n  }\n});\n\nAFRAME.registerPrimitive('rw-sides', {\n  defaultComponents: { sides: {} },\n  mappings: {}\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsb0NBQW9DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLHlDQUF5QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qyw2Q0FBNkM7QUFDcEY7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLDJCQUEyQjtBQUN2RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsaUNBQWlDO0FBQ2xFO0FBQ0Esb0VBQW9FO0FBQ3BFLGtFQUFrRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3Qyx1REFBdUQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyx1REFBdUQsa0JBQWtCO0FBQ3pFLHVEQUF1RCxrQkFBa0I7QUFDekUsdURBQXVELGtCQUFrQjtBQUN6RSx1REFBdUQsa0JBQWtCO0FBQ3pFLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLDBCQUEwQjtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQseUNBQXlDO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUzs7QUFFckM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3Qyx1REFBdUQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsMEJBQTBCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxrREFBa0Q7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsaUNBQWlDO0FBQ3ZFO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBLHdDQUF3QyxlQUFlO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRDtBQUMxRCx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMscURBQXFEO0FBQ2xHO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBLDBDQUEwQywrQkFBK0I7QUFDekU7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQywwQkFBMEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQkFBMEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDO0FBQzlFOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDLG9DQUFvQztBQUNwQyw4Q0FBOEM7QUFDOUMsNENBQTRDOztBQUU1Qyx5Q0FBeUMsb0RBQW9EO0FBQzdGO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBLHFDQUFxQyw2QkFBNkI7QUFDbEU7O0FBRUEsc0RBQXNEOztBQUV0RDs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLENBQUM7O0FBRUQ7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsY0FBYyw4QkFBOEI7QUFDNUMsYUFBYSxnQkFBZ0I7QUFDN0IsY0FBYztBQUNkOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsVUFBVSxrQkFBa0I7QUFDNUIsY0FBYyw4QkFBOEI7QUFDNUMsYUFBYTtBQUNiOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZnJhbWUtcm9vbS1jb21wb25lbnQvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbkFGUkFNRS5yZWdpc3RlclN5c3RlbSgnYnVpbGRpbmcnLCB7XG5cbiAgcmVleGFtaW5lQnVpbGRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIiA9IFJFRVZBTFVBVElPTiBSRVFVRVNURUQuLi5cIik7XG5cbiAgICBjb25zdCBidWlsZGluZ1NlbGYgPSB0aGlzO1xuICAgIGNvbnN0IEhBSVIgPSAwLjAwMDE7XG5cbiAgICAvKlxuXG4gICAgaHR0cHM6Ly9naXRodWIuY29tL29wYXJhbW8vYWZyYW1lLXJvb20tY29tcG9uZW50XG4gICAgdjAuNS4wXG5cbiAgICBPUFRJTUlaQVRJT046XG5cbiAgICBjdXJyZW50bHksIHRoZSBlbnRpcmUgYnVpbGRpbmcgaXMgZ2V0dGluZyByZS1nZW5lcmF0ZWQgZnJvbSBzY3JhdGNoIGFueSB0aW1lIGFueXRoaW5nIGluIGl0IGNoYW5nZXMuXG4gICAgb2J2aW91c2x5IHRoaXMgaXMgd2FzdGVmdWwsIGJ1dDpcbiAgICAtIHRoaXMgbGlicmFyeSBpc24ndCBwYXJ0aWN1bGFybHkgbGlrZWx5IHRvIGJlIHVzZWQgaW4gYSBjb250ZXh0IHdoZXJlIHRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZSBjaGFuZ2luZyBhdCBydW50aW1lIChhdCBsZWFzdCBvdXRzaWRlIG9mIGRlYnVnZ2luZylcbiAgICAtIHJpZ2h0IG5vdyBJIGFtIG1vcmUgY29uY2VybmVkIHdpdGggZ2V0dGluZyBpdCBvdXQgdGhlIGRvb3IgdGhhbiBtYWtpbmcgaXQgcGVyZmVjdCBhbnl3YXlcblxuICAgIFBMQU5ORUQgRkVBVFVSRVMgVE8gQ09NRSAoaW4gb3JkZXIpOlxuICAgIC0gZ3JlYXRlciBjb250cm9sIG92ZXIgVVYgZ2VuZXJhdGlvblxuICAgIC0gYXV0b21hdGljIGNvbGxpc2lvbiBhc3NpZ25tZW50XG4gICAgLSBkb29ycyBsaWZ0ZWQgYWJvdmUgdGhlIGdyb3VuZCAoaS5lLiB3aW5kb3dzKVxuICAgIC0gYWNjZXB0IGEgc2hhcGUgdG8gYmUgZXh0cnVkZWQgYXJvdW5kIGEgZG9vcmhvbGUgdG8gbWFrZSBhIGRvb3JmcmFtZSAoJiBhcm91bmQgYSBmbG9vciB0byBtYWtlIGEgYmFzZWJvYXJkKVxuXG4gICAgS05PV04gSVNTVUVTICh3aXRoIG5vIG9idmlvdXMgc29sdXRpb24gdGhhdCB3b3VsZCBwcmVzZXJ2ZSBlYXNlIG9mIHVzZSk6XG4gICAgLSBmbG9vci9jZWlsaW5nIHRyaWFuZ3VsYXRpb24gaXMgbm90IGNvbnRyb2xsYWJsZSAoYW5kIHRoZXJlZm9yZSB2YXJ5aW5nIHdhbGwgdmVydGljYWxpdHkgaXMgbmVhcmx5IHVzZWxlc3MgdW5sZXNzIHNsb3BlIGlzIGNvbnNpc3RlbnQpXG4gICAgLSBkb29yaG9sZSBwYXJlbnRpbmcgaXMgYWx3YXlzIGxldmVsIHRvIHRoZSBob3Jpem9uIGV2ZW4gb24gc2xvcGUtZmxvb3JlZCB3YWxsc1xuICAgIC0gdGhlIHNldFRpbWVvdXQgdGhpbmcgcmVzdWx0cyBpbiBhIG9uZS1mcmFtZSBmbGFzaCBvZiBpbnZpc2libGUgd2FsbHM6IGlzIGl0IHdvcnRoIGl0PyAoaXMgdGhlcmUgYSBzbWFydGVyIHRoaW5nIHRvIGxpc3RlbiBmb3IsIG1heWJlPylcblxuICAgIElTU1VFUyBUSEFUIENPVUxEIFRIRU9SRVRJQ0FMTFkgQkUgRklYRUQgQlVUIERPTidUIFNFRU0gV09SVEggVEhFIFRST1VCTEU6XG4gICAgLSB3YWxscyBhcmUgaW50ZXJuYWxseSByZWFycmFuZ2VkIHRvIGFsd2F5cyB3aW5kIENXLCB3aGljaCBtZWFucyB3YWxsIHBhcmVudGluZyB3aWxsIHBvaW50IHRvd2FyZHMgdGhlIFwicHJldmlvdXNcIiB3YWxsIGlmIHlvdSBlbnRlcmVkIHRoZW0gaW4gQ0NXIG9yZGVyXG5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZmxpcEdlb20gKGdlb20pIHtcbiAgICAgIGNvbnN0IGluZGV4Q29weSA9IGdlb20uaW5kZXg7XG4gICAgICBmb3IgKGxldCBjdXJGYWNlSW5kZXggPSAwOyBjdXJGYWNlSW5kZXggPCBpbmRleENvcHkuY291bnQgLyAzOyBjdXJGYWNlSW5kZXgrKykge1xuICAgICAgICBjb25zdCBidWNrZXQgPSBpbmRleENvcHlbY3VyRmFjZUluZGV4ICogMyArIDJdO1xuICAgICAgICBpbmRleENvcHlbY3VyRmFjZUluZGV4ICogMyArIDJdID0gaW5kZXhDb3B5W2N1ckZhY2VJbmRleCAqIDMgKyAxXTtcbiAgICAgICAgaW5kZXhDb3B5W2N1ckZhY2VJbmRleCAqIDMgKyAxXSA9IGJ1Y2tldDtcbiAgICAgIH1cbiAgICAgIGdlb20uc2V0SW5kZXgoaW5kZXhDb3B5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlVXZzRm9yR2VvbSAoZ2VvbSwgY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGFsbFVWcyA9IFtdO1xuICAgICAgZm9yIChsZXQgZmFjZVZlcnRJbmRleCA9IDA7IGZhY2VWZXJ0SW5kZXggPCBnZW9tLmluZGV4LmFycmF5Lmxlbmd0aDsgZmFjZVZlcnRJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHZlcnRleEluZGV4ID0gZ2VvbS5pbmRleC5hcnJheVtmYWNlVmVydEluZGV4XTtcbiAgICAgICAgY29uc3QgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgICAgZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmdldFgodmVydGV4SW5kZXgpLFxuICAgICAgICAgIGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5nZXRZKHZlcnRleEluZGV4KSxcbiAgICAgICAgICBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uZ2V0Wih2ZXJ0ZXhJbmRleClcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdXYgPSBjYWxsYmFjayh2ZXJ0ZXgsIGZhY2VWZXJ0SW5kZXggJSAzKTtcbiAgICAgICAgYWxsVVZzW3ZlcnRleEluZGV4ICogMiArIDBdID0gdXZbMF07XG4gICAgICAgIGFsbFVWc1t2ZXJ0ZXhJbmRleCAqIDIgKyAxXSA9IHV2WzFdO1xuICAgICAgfVxuICAgICAgZ2VvbS5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGFsbFVWcyksIDIpKTtcbiAgICAgIGdlb20udXZzTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VQbGFuZVV2cyAoZ2VvbSwgdUtleSwgdktleSwgdU11bHQsIHZNdWx0KSB7XG4gICAgICBtYWtlVXZzRm9yR2VvbShnZW9tLCAocHQpID0+IHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBwdFt1S2V5XSAqIHVNdWx0LFxuICAgICAgICAgIHB0W3ZLZXldICogdk11bHRcbiAgICAgICAgXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmlzaEdlb20gKGdlb20pIHtcbiAgICAgIGdlb20uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcbiAgICAgIC8vIGFyZSB0aGVzZSBuZWNlc3Nhcnk/XG4gICAgICBnZW9tLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgICAgZ2VvbS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRVbnNvcnRlZFJvb21XYWxsQXJyYXkgKHJvb21FbCkge1xuICAgICAgY29uc3Qgd2FsbHMgPSBbXTtcbiAgICAgIGZvciAobGV0IHJvb21DaGlsZE5vZGVJbmRleCA9IDA7IHJvb21DaGlsZE5vZGVJbmRleCA8IHJvb21FbC5jaGlsZHJlbi5sZW5ndGg7IHJvb21DaGlsZE5vZGVJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHJvb21DaGlsZE5vZGUgPSByb29tRWwuY2hpbGRyZW5bcm9vbUNoaWxkTm9kZUluZGV4XTtcbiAgICAgICAgaWYgKHJvb21DaGlsZE5vZGUuY29tcG9uZW50cy53YWxsKSB7IHdhbGxzLnB1c2gocm9vbUNoaWxkTm9kZSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB3YWxscztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRSb29tV2FsbEFycmF5IChyb29tRWwpIHtcbiAgICAgIC8vIHRoZSByZXN1bHRzIG9mIHRoaXMgbm90IGJlaW5nIHNhdmVkIGFueXdoZXJlIGlzIHN1cGVyIHdhc3RlZnVsLFxuICAgICAgLy8gYnV0LCBzZWUgYWJvdmU7IG5vdCB3b3J0aCB3b3JyeWluZyBhYm91dCB5ZXRcblxuICAgICAgY29uc3QgaXNPdXRzaWRlID0gcm9vbUVsLmNvbXBvbmVudHMucm9vbS5kYXRhLm91dHNpZGU7XG5cbiAgICAgIGNvbnN0IHdhbGxzID0gZ2V0VW5zb3J0ZWRSb29tV2FsbEFycmF5KHJvb21FbCk7XG5cbiAgICAgIGxldCBjd1N1bSA9IDA7XG4gICAgICBmb3IgKGxldCB3YWxsSW5kZXggPSAwOyB3YWxsSW5kZXggPCB3YWxscy5sZW5ndGg7IHdhbGxJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGN1cldhbGxOb2RlID0gd2FsbHNbd2FsbEluZGV4XTtcbiAgICAgICAgY29uc3QgbmV4dFdhbGxOb2RlID0gd2FsbHNbKHdhbGxJbmRleCArIDEpICUgd2FsbHMubGVuZ3RoXTtcbiAgICAgICAgY29uc3QgY3VyV2FsbFBvcyA9IGN1cldhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YTtcbiAgICAgICAgY29uc3QgbmV4dFdhbGxQb3MgPSBuZXh0V2FsbE5vZGUuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhO1xuXG4gICAgICAgIGN3U3VtICs9IChuZXh0V2FsbFBvcy54IC0gY3VyV2FsbFBvcy54KSAqIChuZXh0V2FsbFBvcy56ICsgY3VyV2FsbFBvcy56KTtcbiAgICAgIH1cblxuICAgICAgbGV0IHNob3VsZFJldmVyc2UgPSBmYWxzZTtcbiAgICAgIGlmIChjd1N1bSA+IDApIHsgc2hvdWxkUmV2ZXJzZSA9ICFzaG91bGRSZXZlcnNlOyB9XG4gICAgICBpZiAoaXNPdXRzaWRlKSB7IHNob3VsZFJldmVyc2UgPSAhc2hvdWxkUmV2ZXJzZTsgfVxuICAgICAgaWYgKHNob3VsZFJldmVyc2UpIHsgd2FsbHMucmV2ZXJzZSgpOyB9XG5cbiAgICAgIHJldHVybiB3YWxscztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TmV4dFdhbGxFbCAod2FsbEVsKSB7XG4gICAgICBjb25zdCB3YWxsTGlzdCA9IGdldFJvb21XYWxsQXJyYXkod2FsbEVsLnBhcmVudE5vZGUpO1xuICAgICAgY29uc3QgY3VyV2FsbEluZGV4ID0gd2FsbExpc3QuaW5kZXhPZih3YWxsRWwpO1xuICAgICAgcmV0dXJuIHdhbGxMaXN0WyhjdXJXYWxsSW5kZXggKyAxKSAlIHdhbGxMaXN0Lmxlbmd0aF07XG4gICAgfVxuXG4gICAgY29uc3Qgd29ybGRXYWxsUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCB3b3JsZE5leHRQb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGNvbnN0IHdvcmxkTGlua1BvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgZnVuY3Rpb24gbW92ZUZvckxpbmsgKGRvb3Job2xlRWwsIGRvb3JsaW5rRWwpIHtcbiAgICAgIGNvbnN0IGhvbGVXYWxsRWwgPSBkb29yaG9sZUVsLnBhcmVudE5vZGU7XG4gICAgICBjb25zdCBuZXh0V2FsbEVsID0gZ2V0TmV4dFdhbGxFbChob2xlV2FsbEVsKTtcbiAgICAgIGlmICghbmV4dFdhbGxFbCkgeyByZXR1cm47IH1cblxuICAgICAgaG9sZVdhbGxFbC5vYmplY3QzRC5nZXRXb3JsZFBvc2l0aW9uKHdvcmxkV2FsbFBvcyk7XG4gICAgICBuZXh0V2FsbEVsLm9iamVjdDNELmdldFdvcmxkUG9zaXRpb24od29ybGROZXh0UG9zKTtcbiAgICAgIGRvb3JsaW5rRWwub2JqZWN0M0QuZ2V0V29ybGRQb3NpdGlvbih3b3JsZExpbmtQb3MpO1xuXG4gICAgICBjb25zdCBsaW5rR2FwWCA9IHdvcmxkTGlua1Bvcy54IC0gd29ybGRXYWxsUG9zLng7XG4gICAgICBjb25zdCBsaW5rR2FwWiA9IHdvcmxkTGlua1Bvcy56IC0gd29ybGRXYWxsUG9zLno7XG5cbiAgICAgIGNvbnN0IHdhbGxHYXBYID0gd29ybGROZXh0UG9zLnggLSB3b3JsZFdhbGxQb3MueDtcbiAgICAgIGNvbnN0IHdhbGxHYXBaID0gd29ybGROZXh0UG9zLnogLSB3b3JsZFdhbGxQb3MuejtcbiAgICAgIGNvbnN0IHdhbGxBbmcgPSBNYXRoLmF0YW4yKHdhbGxHYXBaLCB3YWxsR2FwWCk7XG4gICAgICBjb25zdCB3YWxsTGVuZ3RoID0gTWF0aC5zcXJ0KHdhbGxHYXBYICogd2FsbEdhcFggKyB3YWxsR2FwWiAqIHdhbGxHYXBaKTtcblxuICAgICAgbGV0IGxvY2FsTGlua1ggPSBsaW5rR2FwWCAqIE1hdGguY29zKC13YWxsQW5nKSAtIGxpbmtHYXBaICogTWF0aC5zaW4oLXdhbGxBbmcpO1xuICAgICAgLy8gdmFyIGxvY2FsTGlua1ogPSBsaW5rR2FwWCpNYXRoLnNpbigtd2FsbEFuZykgKyBsaW5rR2FwWipNYXRoLmNvcygtd2FsbEFuZyk7XG5cbiAgICAgIGNvbnN0IGRvb3JIYWxmID0gZG9vcmxpbmtFbC5jb21wb25lbnRzLmRvb3JsaW5rLmRhdGEud2lkdGggLyAyO1xuICAgICAgbG9jYWxMaW5rWCA9IE1hdGgubWF4KGxvY2FsTGlua1gsIGRvb3JIYWxmICsgSEFJUik7XG4gICAgICBsb2NhbExpbmtYID0gTWF0aC5taW4obG9jYWxMaW5rWCwgd2FsbExlbmd0aCAtIGRvb3JIYWxmIC0gSEFJUik7XG5cbiAgICAgIGRvb3Job2xlRWwuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIHsgeDogbG9jYWxMaW5rWCwgeTogMCwgejogMCB9KTtcbiAgICAgIGRvb3Job2xlRWwub2JqZWN0M0QudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRIb2xlTGluayAoZG9vcmhvbGVFbCkge1xuICAgICAgY29uc3QgZG9vcmxpbmtzID0gYnVpbGRpbmdTZWxmLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkb29ybGlua10nKTtcbiAgICAgIGZvciAobGV0IGN1ckxpbmtJbmRleCA9IDA7IGN1ckxpbmtJbmRleCA8IGRvb3JsaW5rcy5sZW5ndGg7IGN1ckxpbmtJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGN1ckxpbmsgPSBkb29ybGlua3NbY3VyTGlua0luZGV4XTtcbiAgICAgICAgaWYgKGN1ckxpbmsuY29tcG9uZW50cy5kb29ybGluay5kYXRhLmZyb20gPT09IGRvb3Job2xlRWwpIHsgcmV0dXJuIGN1ckxpbms7IH1cbiAgICAgICAgaWYgKGN1ckxpbmsuY29tcG9uZW50cy5kb29ybGluay5kYXRhLnRvID09PSBkb29yaG9sZUVsKSB7IHJldHVybiBjdXJMaW5rOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2FsbEhlaWdodCAod2FsbEVsKSB7XG4gICAgICBpZiAod2FsbEVsLmNvbXBvbmVudHMud2FsbC5kYXRhLmhlaWdodCkgeyByZXR1cm4gd2FsbEVsLmNvbXBvbmVudHMud2FsbC5kYXRhLmhlaWdodDsgfVxuICAgICAgcmV0dXJuIHdhbGxFbC5wYXJlbnROb2RlLmNvbXBvbmVudHMucm9vbS5kYXRhLmhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAoYnVpbGRpbmdTZWxmLmRpcnR5KSB7IHJldHVybjsgfVxuICAgIGJ1aWxkaW5nU2VsZi5kaXJ0eSA9IHRydWU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIiA9PSBTVEFSVElORyBSRS1FVkFMVUFUSU9OLi4uXCIpO1xuXG4gICAgICAvLyBzaWxseSBidXQgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgdGhyZWVKUyB3ZWlyZG5lc3NcbiAgICAgIGJ1aWxkaW5nU2VsZi5lbC5vYmplY3QzRC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgICAvLyBsYXkgb3V0IHdhbGxzJyBhbmdsZXM6XG5cbiAgICAgIGZvciAobGV0IHNjZW5lQ2hpbGROb2RlSW5kZXggPSAwOyBzY2VuZUNoaWxkTm9kZUluZGV4IDwgYnVpbGRpbmdTZWxmLmVsLmNoaWxkcmVuLmxlbmd0aDsgc2NlbmVDaGlsZE5vZGVJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHNjZW5lQ2hpbGROb2RlID0gYnVpbGRpbmdTZWxmLmVsLmNoaWxkcmVuW3NjZW5lQ2hpbGROb2RlSW5kZXhdO1xuICAgICAgICBpZiAoc2NlbmVDaGlsZE5vZGUuY29tcG9uZW50cyAmJiBzY2VuZUNoaWxkTm9kZS5jb21wb25lbnRzLnJvb20pIHtcbiAgICAgICAgICBjb25zdCB3ID0gc2NlbmVDaGlsZE5vZGUuY29tcG9uZW50cy5yb29tLmRhdGEud2lkdGg7XG4gICAgICAgICAgY29uc3QgbCA9IHNjZW5lQ2hpbGROb2RlLmNvbXBvbmVudHMucm9vbS5kYXRhLmxlbmd0aDtcbiAgICAgICAgICBpZiAodyB8fCBsKSB7XG4gICAgICAgICAgICBpZiAodyAmJiBsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJhd1dhbGxzID0gZ2V0VW5zb3J0ZWRSb29tV2FsbEFycmF5KHNjZW5lQ2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgaWYgKHJhd1dhbGxzLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1dhbGxzLmxlbmd0aCA+IDQpIHsgY29uc29sZS5lcnJvcigncm9vbXMgd2l0aCBXSURUSCBhbmQgTEVOR1RIIHNob3VsZCBvbmx5IGhhdmUgZm91ciB3YWxscyEnKTsgfVxuICAgICAgICAgICAgICAgIHJhd1dhbGxzWzBdLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCB7IHg6IDAsIHk6IDAsIHo6IDAgfSk7XG4gICAgICAgICAgICAgICAgcmF3V2FsbHNbMV0uc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIHsgeDogdywgeTogMCwgejogMCB9KTtcbiAgICAgICAgICAgICAgICByYXdXYWxsc1syXS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgeyB4OiB3LCB5OiAwLCB6OiBsIH0pO1xuICAgICAgICAgICAgICAgIHJhd1dhbGxzWzNdLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCB7IHg6IDAsIHk6IDAsIHo6IGwgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigncm9vbXMgd2l0aCBXSURUSCBhbmQgTEVOR1RIIG11c3QgaGF2ZSBmb3VyIHdhbGxzIScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyb29tcyB3aXRoIFdJRFRIIG11c3QgYWxzbyBoYXZlIExFTkdUSCAoYW5kIHZpY2UgdmVyc2EpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgd2FsbHMgPSBnZXRSb29tV2FsbEFycmF5KHNjZW5lQ2hpbGROb2RlKTtcbiAgICAgICAgICBpZiAod2FsbHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgZm9yIChsZXQgd2FsbEluZGV4ID0gMDsgd2FsbEluZGV4IDwgd2FsbHMubGVuZ3RoOyB3YWxsSW5kZXgrKykge1xuICAgICAgICAgICAgICBjb25zdCBjdXJXYWxsTm9kZSA9IHdhbGxzW3dhbGxJbmRleF07XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRXYWxsTm9kZSA9IHdhbGxzWyh3YWxsSW5kZXggKyAxKSAlIHdhbGxzLmxlbmd0aF07XG5cbiAgICAgICAgICAgICAgY29uc3Qgd2FsbEdhcFggPSBuZXh0V2FsbE5vZGUuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLnggLSBjdXJXYWxsTm9kZS5jb21wb25lbnRzLnBvc2l0aW9uLmRhdGEueDtcbiAgICAgICAgICAgICAgY29uc3Qgd2FsbEdhcFogPSBuZXh0V2FsbE5vZGUuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLnogLSBjdXJXYWxsTm9kZS5jb21wb25lbnRzLnBvc2l0aW9uLmRhdGEuejtcbiAgICAgICAgICAgICAgY29uc3Qgd2FsbEFuZyA9IE1hdGguYXRhbjIod2FsbEdhcFosIHdhbGxHYXBYKTtcblxuICAgICAgICAgICAgICBjdXJXYWxsTm9kZS5zZXRBdHRyaWJ1dGUoJ3JvdGF0aW9uJywgeyB4OiAwLCB5OiAtd2FsbEFuZyAvIE1hdGguUEkgKiAxODAsIHo6IDAgfSk7XG4gICAgICAgICAgICAgIGN1cldhbGxOb2RlLm9iamVjdDNELnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHBvc2l0aW9uIHRoZSBkb29yIGhvbGVzOlxuXG4gICAgICBjb25zdCBkb29ybGlua3MgPSBidWlsZGluZ1NlbGYuZWwucXVlcnlTZWxlY3RvckFsbCgnW2Rvb3JsaW5rXScpO1xuICAgICAgZm9yIChsZXQgY3VyRG9vcmxpbmtFbEluZGV4ID0gMDsgY3VyRG9vcmxpbmtFbEluZGV4IDwgZG9vcmxpbmtzLmxlbmd0aDsgY3VyRG9vcmxpbmtFbEluZGV4KyspIHtcbiAgICAgICAgY29uc3QgY3VyRG9vcmxpbmtFbCA9IGRvb3JsaW5rc1tjdXJEb29ybGlua0VsSW5kZXhdO1xuICAgICAgICBjb25zdCBjdXJEb29ybGluayA9IGN1ckRvb3JsaW5rRWwuY29tcG9uZW50cy5kb29ybGluaztcbiAgICAgICAgaWYgKCFjdXJEb29ybGluaykgeyByZXR1cm47IH0vLyBzdGlsbCBzZXR0aW5nIHVwLCB0cnkgYWdhaW4gbGF0ZXJcblxuICAgICAgICBtb3ZlRm9yTGluayhjdXJEb29ybGluay5kYXRhLmZyb20sIGN1ckRvb3JsaW5rLmVsKTtcbiAgICAgICAgbW92ZUZvckxpbmsoY3VyRG9vcmxpbmsuZGF0YS50bywgY3VyRG9vcmxpbmsuZWwpO1xuICAgICAgfVxuXG4gICAgICAvLyBnZW5lcmF0ZSB0aGUgd2FsbHMnIGdlb21ldHJ5OlxuXG4gICAgICBmb3IgKGxldCBzY2VuZUNoaWxkTm9kZUluZGV4ID0gMDsgc2NlbmVDaGlsZE5vZGVJbmRleCA8IGJ1aWxkaW5nU2VsZi5lbC5jaGlsZHJlbi5sZW5ndGg7IHNjZW5lQ2hpbGROb2RlSW5kZXgrKykge1xuICAgICAgICBjb25zdCBzY2VuZUNoaWxkTm9kZSA9IGJ1aWxkaW5nU2VsZi5lbC5jaGlsZHJlbltzY2VuZUNoaWxkTm9kZUluZGV4XTtcbiAgICAgICAgaWYgKHNjZW5lQ2hpbGROb2RlLmNvbXBvbmVudHMgJiYgc2NlbmVDaGlsZE5vZGUuY29tcG9uZW50cy5yb29tKSB7XG4gICAgICAgICAgY29uc3QgaXNPdXRzaWRlID0gc2NlbmVDaGlsZE5vZGUuY29tcG9uZW50cy5yb29tLmRhdGEub3V0c2lkZTtcbiAgICAgICAgICBjb25zdCB3YWxscyA9IGdldFJvb21XYWxsQXJyYXkoc2NlbmVDaGlsZE5vZGUpO1xuXG4gICAgICAgICAgaWYgKHdhbGxzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHdhbGxJbmRleCA9IDA7IHdhbGxJbmRleCA8IHdhbGxzLmxlbmd0aDsgd2FsbEluZGV4KyspIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VyV2FsbE5vZGUgPSB3YWxsc1t3YWxsSW5kZXhdO1xuICAgICAgICAgICAgICBjb25zdCBuZXh0V2FsbE5vZGUgPSB3YWxsc1sod2FsbEluZGV4ICsgMSkgJSB3YWxscy5sZW5ndGhdO1xuXG4gICAgICAgICAgICAgIGNvbnN0IHdhbGxHYXBYID0gbmV4dFdhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS54IC0gY3VyV2FsbE5vZGUuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLng7XG4gICAgICAgICAgICAgIGNvbnN0IHdhbGxHYXBaID0gbmV4dFdhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS56IC0gY3VyV2FsbE5vZGUuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLno7XG4gICAgICAgICAgICAgIGNvbnN0IHdhbGxMZW5ndGggPSBNYXRoLnNxcnQod2FsbEdhcFggKiB3YWxsR2FwWCArIHdhbGxHYXBaICogd2FsbEdhcFopO1xuICAgICAgICAgICAgICAvLyB2YXIgd2FsbEFuZyA9IE1hdGguYXRhbjIod2FsbEdhcFosIHdhbGxHYXBYKTtcblxuICAgICAgICAgICAgICBjb25zdCB3YWxsR2FwWSA9IG5leHRXYWxsTm9kZS5jb21wb25lbnRzLnBvc2l0aW9uLmRhdGEueSAtIGN1cldhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS55O1xuICAgICAgICAgICAgICBjb25zdCBoZWlnaHRHYXAgPSBnZXRXYWxsSGVpZ2h0KG5leHRXYWxsTm9kZSkgLSBnZXRXYWxsSGVpZ2h0KGN1cldhbGxOb2RlKTtcblxuICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkSG9sZXMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgd2FsbENoaWxkTm9kZUluZGV4ID0gMDsgd2FsbENoaWxkTm9kZUluZGV4IDwgY3VyV2FsbE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyB3YWxsQ2hpbGROb2RlSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxDaGlsZE5vZGUgPSBjdXJXYWxsTm9kZS5jaGlsZHJlblt3YWxsQ2hpbGROb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh3YWxsQ2hpbGROb2RlLmNvbXBvbmVudHMgJiYgd2FsbENoaWxkTm9kZS5jb21wb25lbnRzLmRvb3Job2xlKSB7XG4gICAgICAgICAgICAgICAgICBvcmRlcmVkSG9sZXMucHVzaCh3YWxsQ2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3JkZXJlZEhvbGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5jb21wb25lbnRzLnBvc2l0aW9uLmRhdGEueCAtIGIuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLng7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNvbnN0IHdhbGxTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xuICAgICAgICAgICAgICB3YWxsU2hhcGUubW92ZVRvKFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgZ2V0V2FsbEhlaWdodChjdXJXYWxsTm9kZSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgd2FsbFNoYXBlLmxpbmVUbyhcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBmb3IgKGxldCBob2xlSW5kZXggPSAwOyBob2xlSW5kZXggPCBvcmRlcmVkSG9sZXMubGVuZ3RoOyBob2xlSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvbGVFbCA9IG9yZGVyZWRIb2xlc1tob2xlSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICghaG9sZUVsLm15VmVydHMpIHsgaG9sZUVsLm15VmVydHMgPSBbXTsgfVxuICAgICAgICAgICAgICAgIGhvbGVFbC5teVZlcnRzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rRWwgPSBnZXRIb2xlTGluayhvcmRlcmVkSG9sZXNbaG9sZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rRWwpIHsgY29udGludWU7IH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGhvbGVJbmZvID0gaG9sZUVsLmNvbXBvbmVudHM7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlua0luZm8gPSBsaW5rRWwuY29tcG9uZW50cztcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGhvbGVTaWRlID0gLTE7IGhvbGVTaWRlIDw9IDE7IGhvbGVTaWRlICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHB0WCA9IGhvbGVJbmZvLnBvc2l0aW9uLmRhdGEueCArIGxpbmtJbmZvLmRvb3JsaW5rLmRhdGEud2lkdGggLyAyICogaG9sZVNpZGU7XG4gICAgICAgICAgICAgICAgICBjb25zdCBmbG9vclkgPSAocHRYIC8gd2FsbExlbmd0aCkgKiB3YWxsR2FwWTtcbiAgICAgICAgICAgICAgICAgIGxldCB0b3BZID0gZmxvb3JZICsgbGlua0luZm8uZG9vcmxpbmsuZGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ckNlaWwgPSBnZXRXYWxsSGVpZ2h0KGN1cldhbGxOb2RlKSArIChwdFggLyB3YWxsTGVuZ3RoKSAqIGhlaWdodEdhcDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1heFRvcFkgPSBmbG9vclkgKyBjdXJDZWlsIC0gSEFJUjsvLyB3aWxsIGFsd2F5cyBiZSBhIHNlYW0sIGJ1dCwgSSdtIG5vdCBib3RoZXJpbmcgdG8gcmV3cml0ZSBqdXN0IGZvciB0aGF0XG4gICAgICAgICAgICAgICAgICBpZiAodG9wWSA+IG1heFRvcFkpIHsgdG9wWSA9IG1heFRvcFk7IH1cblxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkV29ybGRWZXJ0IChwdFkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcFBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKHB0WCwgcHRZLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY3VyV2FsbE5vZGUub2JqZWN0M0QubG9jYWxUb1dvcmxkKHRlbXBQb3MpO1xuICAgICAgICAgICAgICAgICAgICBob2xlRWwubXlWZXJ0cy5wdXNoKHRlbXBQb3MpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0KGZsb29yWSk7XG4gICAgICAgICAgICAgICAgICBhZGRXb3JsZFZlcnQodG9wWSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChob2xlU2lkZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd2FsbFNoYXBlLmxpbmVUbyhwdFgsIGZsb29yWSk7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxTaGFwZS5saW5lVG8ocHRYLCB0b3BZKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxTaGFwZS5saW5lVG8ocHRYLCB0b3BZKTtcbiAgICAgICAgICAgICAgICAgICAgd2FsbFNoYXBlLmxpbmVUbyhwdFgsIGZsb29yWSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgd2FsbFNoYXBlLmxpbmVUbyhcbiAgICAgICAgICAgICAgICB3YWxsTGVuZ3RoLFxuICAgICAgICAgICAgICAgIG5leHRXYWxsTm9kZS5jb21wb25lbnRzLnBvc2l0aW9uLmRhdGEueSAtIGN1cldhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS55XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHdhbGxTaGFwZS5saW5lVG8oXG4gICAgICAgICAgICAgICAgd2FsbExlbmd0aCxcbiAgICAgICAgICAgICAgICAobmV4dFdhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS55IC0gY3VyV2FsbE5vZGUuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLnkpICsgZ2V0V2FsbEhlaWdodChuZXh0V2FsbE5vZGUpXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgY29uc3Qgd2FsbEdlb20gPSBuZXcgVEhSRUUuU2hhcGVHZW9tZXRyeSh3YWxsU2hhcGUpO1xuICAgICAgICAgICAgICBtYWtlUGxhbmVVdnMod2FsbEdlb20sICd4JywgJ3knLCAxLCAxKTtcbiAgICAgICAgICAgICAgZmluaXNoR2VvbSh3YWxsR2VvbSk7XG4gICAgICAgICAgICAgIGNvbnN0IG15TWF0ID0gY3VyV2FsbE5vZGUuY29tcG9uZW50cy5tYXRlcmlhbCA/IGN1cldhbGxOb2RlLmNvbXBvbmVudHMubWF0ZXJpYWwubWF0ZXJpYWwgOiBjdXJXYWxsTm9kZS5wYXJlbnROb2RlLmNvbXBvbmVudHMubWF0ZXJpYWwubWF0ZXJpYWw7XG4gICAgICAgICAgICAgIGlmIChjdXJXYWxsTm9kZS5teU1lc2gpIHtcbiAgICAgICAgICAgICAgICBjdXJXYWxsTm9kZS5teU1lc2guZ2VvbWV0cnkgPSB3YWxsR2VvbTtcbiAgICAgICAgICAgICAgICBjdXJXYWxsTm9kZS5teU1lc2gubWF0ZXJpYWwgPSBteU1hdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJXYWxsTm9kZS5teU1lc2ggPSBuZXcgVEhSRUUuTWVzaCh3YWxsR2VvbSwgbXlNYXQpO1xuICAgICAgICAgICAgICAgIGN1cldhbGxOb2RlLnNldE9iamVjdDNEKCd3YWxsTWVzaCcsIGN1cldhbGxOb2RlLm15TWVzaCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2FwcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgcm9vbUNoaWxkTm9kZUluZGV4ID0gMDsgcm9vbUNoaWxkTm9kZUluZGV4IDwgc2NlbmVDaGlsZE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyByb29tQ2hpbGROb2RlSW5kZXgrKykge1xuICAgICAgICAgICAgICBjb25zdCByb29tQ2hpbGROb2RlID0gc2NlbmVDaGlsZE5vZGUuY2hpbGRyZW5bcm9vbUNoaWxkTm9kZUluZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHJvb21DaGlsZE5vZGUuY29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChyb29tQ2hpbGROb2RlLmNvbXBvbmVudHMuZmxvb3IgfHwgcm9vbUNoaWxkTm9kZS5jb21wb25lbnRzLmNlaWxpbmcpIHsgY2Fwcy5wdXNoKHJvb21DaGlsZE5vZGUpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGN1ckNhcE5vZGVJbmRleCA9IDA7IGN1ckNhcE5vZGVJbmRleCA8IGNhcHMubGVuZ3RoOyBjdXJDYXBOb2RlSW5kZXgrKykge1xuICAgICAgICAgICAgICBjb25zdCBjdXJDYXBOb2RlID0gY2Fwc1tjdXJDYXBOb2RlSW5kZXhdO1xuICAgICAgICAgICAgICBjb25zdCBpc0NlaWxpbmcgPSBjdXJDYXBOb2RlLmNvbXBvbmVudHMuY2VpbGluZztcblxuICAgICAgICAgICAgICBjb25zdCBjYXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xuICAgICAgICAgICAgICBmb3IgKGxldCB3YWxsSW5kZXggPSAwOyB3YWxsSW5kZXggPCB3YWxscy5sZW5ndGg7IHdhbGxJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyV2FsbE5vZGUgPSB3YWxsc1t3YWxsSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHB0WCA9IGN1cldhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS54O1xuICAgICAgICAgICAgICAgIGNvbnN0IHB0WiA9IGN1cldhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS56O1xuICAgICAgICAgICAgICAgIGlmICh3YWxsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIGNhcFNoYXBlLmxpbmVUbyhwdFgsIHB0Wik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNhcFNoYXBlLm1vdmVUbyhwdFgsIHB0Wik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGNhcEdlb20gPSBuZXcgVEhSRUUuU2hhcGVHZW9tZXRyeShjYXBTaGFwZSk7XG4gICAgICAgICAgICAgIGZvciAobGV0IHdhbGxJbmRleCA9IDA7IHdhbGxJbmRleCA8IHdhbGxzLmxlbmd0aDsgd2FsbEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJXYWxsTm9kZSA9IHdhbGxzW3dhbGxJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyVmVydCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgICAgICAgICAgY2FwR2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmdldFgod2FsbEluZGV4KSxcbiAgICAgICAgICAgICAgICAgIGNhcEdlb20uYXR0cmlidXRlcy5wb3NpdGlvbi5nZXRZKHdhbGxJbmRleCksXG4gICAgICAgICAgICAgICAgICBjYXBHZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uZ2V0Wih3YWxsSW5kZXgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjdXJWZXJ0LnNldChjdXJWZXJ0LngsIGN1cldhbGxOb2RlLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS55LCBjdXJWZXJ0LnkpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NlaWxpbmcpIHsgY3VyVmVydC55ICs9IGdldFdhbGxIZWlnaHQoY3VyV2FsbE5vZGUpOyB9XG4gICAgICAgICAgICAgICAgY2FwR2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLnNldFhZWih3YWxsSW5kZXgsIGN1clZlcnQueCwgY3VyVmVydC55LCBjdXJWZXJ0LnopO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGV0IHNob3VsZFJldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKCFpc0NlaWxpbmcpIHsgc2hvdWxkUmV2ZXJzZSA9ICFzaG91bGRSZXZlcnNlOyB9XG4gICAgICAgICAgICAgIGlmIChpc091dHNpZGUpIHsgc2hvdWxkUmV2ZXJzZSA9ICFzaG91bGRSZXZlcnNlOyB9XG4gICAgICAgICAgICAgIGlmIChzaG91bGRSZXZlcnNlKSB7IGZsaXBHZW9tKGNhcEdlb20pOyB9XG5cbiAgICAgICAgICAgICAgbWFrZVBsYW5lVXZzKGNhcEdlb20sICd4JywgJ3onLCBpc0NlaWxpbmcgPyAxIDogLTEsIDEpO1xuICAgICAgICAgICAgICBmaW5pc2hHZW9tKGNhcEdlb20pO1xuXG4gICAgICAgICAgICAgIGlmICghY3VyQ2FwTm9kZS5teU1lc2hlcykgeyBjdXJDYXBOb2RlLm15TWVzaGVzID0gW107IH1cblxuICAgICAgICAgICAgICBjb25zdCB0eXBlTGFiZWwgPSBpc0NlaWxpbmcgPyAnY2VpbGluZycgOiAnZmxvb3InO1xuICAgICAgICAgICAgICBjb25zdCBteU1hdCA9IGN1ckNhcE5vZGUuY29tcG9uZW50cy5tYXRlcmlhbCA/IGN1ckNhcE5vZGUuY29tcG9uZW50cy5tYXRlcmlhbC5tYXRlcmlhbCA6IGN1ckNhcE5vZGUucGFyZW50Tm9kZS5jb21wb25lbnRzLm1hdGVyaWFsLm1hdGVyaWFsO1xuICAgICAgICAgICAgICBpZiAoY3VyQ2FwTm9kZS5teU1lc2hlc1t0eXBlTGFiZWxdKSB7XG4gICAgICAgICAgICAgICAgY3VyQ2FwTm9kZS5teU1lc2hlc1t0eXBlTGFiZWxdLmdlb21ldHJ5ID0gY2FwR2VvbTtcbiAgICAgICAgICAgICAgICBjdXJDYXBOb2RlLm15TWVzaGVzW3R5cGVMYWJlbF0ubWF0ZXJpYWwgPSBteU1hdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJDYXBOb2RlLm15TWVzaGVzW3R5cGVMYWJlbF0gPSBuZXcgVEhSRUUuTWVzaChjYXBHZW9tLCBteU1hdCk7XG4gICAgICAgICAgICAgICAgY3VyQ2FwTm9kZS5zZXRPYmplY3QzRCh0eXBlTGFiZWwsIGN1ckNhcE5vZGUubXlNZXNoZXNbdHlwZUxhYmVsXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2VuZXJhdGUgdGhlIGRvb3IgdHVubmVscycgZ2VvbWV0cnk6XG5cbiAgICAgIGZvciAobGV0IGN1ckRvb3JsaW5rRWxJbmRleCA9IDA7IGN1ckRvb3JsaW5rRWxJbmRleCA8IGRvb3JsaW5rcy5sZW5ndGg7IGN1ckRvb3JsaW5rRWxJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGN1ckRvb3JsaW5rRWwgPSBkb29ybGlua3NbY3VyRG9vcmxpbmtFbEluZGV4XTtcblxuICAgICAgICBjb25zdCBjdXJEb29ybGluayA9IGN1ckRvb3JsaW5rRWwuY29tcG9uZW50cy5kb29ybGluaztcbiAgICAgICAgaWYgKCFjdXJEb29ybGluay5kYXRhLmZyb20pIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKCFjdXJEb29ybGluay5kYXRhLnRvKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghY3VyRG9vcmxpbmsuZGF0YS5mcm9tLm15VmVydHMpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmICghY3VyRG9vcmxpbmsuZGF0YS50by5teVZlcnRzKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGZvciAobGV0IGRvb3JMaW5rQ2hpbGRJbmRleCA9IDA7IGRvb3JMaW5rQ2hpbGRJbmRleCA8IGN1ckRvb3JsaW5rRWwuY2hpbGRyZW4ubGVuZ3RoOyBkb29yTGlua0NoaWxkSW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IGRvb3JMaW5rQ2hpbGQgPSBjdXJEb29ybGlua0VsLmNoaWxkcmVuW2Rvb3JMaW5rQ2hpbGRJbmRleF07XG4gICAgICAgICAgaWYgKCFkb29yTGlua0NoaWxkLmNvbXBvbmVudHMpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIGNvbnN0IHR5cGVzID0gWydzaWRlcycsICdmbG9vcicsICdjZWlsaW5nJ107XG4gICAgICAgICAgZm9yIChsZXQgY3VyVHlwZUluZGV4ID0gMDsgY3VyVHlwZUluZGV4IDwgdHlwZXMubGVuZ3RoOyBjdXJUeXBlSW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgY3VyVHlwZSA9IHR5cGVzW2N1clR5cGVJbmRleF07XG5cbiAgICAgICAgICAgIGlmICghZG9vckxpbmtDaGlsZC5jb21wb25lbnRzW2N1clR5cGVdKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIGNvbnN0IG15TWF0ID0gZG9vckxpbmtDaGlsZC5jb21wb25lbnRzLm1hdGVyaWFsID8gZG9vckxpbmtDaGlsZC5jb21wb25lbnRzLm1hdGVyaWFsLm1hdGVyaWFsIDogZG9vckxpbmtDaGlsZC5wYXJlbnROb2RlLmNvbXBvbmVudHMubWF0ZXJpYWwubWF0ZXJpYWw7XG5cbiAgICAgICAgICAgIGlmICghZG9vckxpbmtDaGlsZC5teUdlb21zKSB7IGRvb3JMaW5rQ2hpbGQubXlHZW9tcyA9IFtdOyB9XG4gICAgICAgICAgICBpZiAoIWRvb3JMaW5rQ2hpbGQubXlHZW9tc1tjdXJUeXBlXSkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJHZW9tID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgICAgICAgICAgIGRvb3JMaW5rQ2hpbGQubXlHZW9tc1tjdXJUeXBlXSA9IGN1ckdlb207XG4gICAgICAgICAgICAgIGNvbnN0IG15TWVzaCA9IG5ldyBUSFJFRS5NZXNoKFxuICAgICAgICAgICAgICAgIGN1ckdlb20sXG4gICAgICAgICAgICAgICAgbXlNYXRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY3VyR2VvbS5tZXNoUmVmID0gbXlNZXNoO1xuICAgICAgICAgICAgICBkb29yTGlua0NoaWxkLnNldE9iamVjdDNEKGN1clR5cGUsIG15TWVzaCk7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4QXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgaW5kZXhBcnJheS5wdXNoKDAsIDEsIDIsIDEsIDMsIDIpO1xuICAgICAgICAgICAgICBpZiAoY3VyVHlwZSA9PT0gJ3NpZGVzJykgeyBpbmRleEFycmF5LnB1c2goNCwgNSwgNiwgNSwgNywgNik7IH1cbiAgICAgICAgICAgICAgY3VyR2VvbS5zZXRJbmRleChpbmRleEFycmF5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY3VyR2VvbSA9IGRvb3JMaW5rQ2hpbGQubXlHZW9tc1tjdXJUeXBlXTtcbiAgICAgICAgICAgIGN1ckdlb20ubWVzaFJlZi5tYXRlcmlhbCA9IG15TWF0O1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25BcnJheSA9IFtdO1xuICAgICAgICAgICAgZnVuY3Rpb24gYWRkV29ybGRWZXJ0ZXggKHB0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxvY2FsUHQgPSBwdC5jbG9uZSgpO1xuICAgICAgICAgICAgICBkb29yTGlua0NoaWxkLm9iamVjdDNELndvcmxkVG9Mb2NhbChsb2NhbFB0KTtcbiAgICAgICAgICAgICAgcG9zaXRpb25BcnJheS5wdXNoKGxvY2FsUHQueCwgbG9jYWxQdC55LCBsb2NhbFB0LnopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gY29tbWl0VmVydGljZXMgKCkge1xuICAgICAgICAgICAgICBjdXJHZW9tLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25BcnJheSksIDMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZWZXJ0cyA9IGN1ckRvb3JsaW5rLmRhdGEuZnJvbS5teVZlcnRzO1xuICAgICAgICAgICAgY29uc3QgdFZlcnRzID0gY3VyRG9vcmxpbmsuZGF0YS50by5teVZlcnRzO1xuICAgICAgICAgICAgc3dpdGNoIChjdXJUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2Zsb29yJzpcblxuICAgICAgICAgICAgICAgIGFkZFdvcmxkVmVydGV4KHRWZXJ0c1swXSk7XG4gICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0ZXgodFZlcnRzWzJdKTtcbiAgICAgICAgICAgICAgICBhZGRXb3JsZFZlcnRleChmVmVydHNbMl0pO1xuICAgICAgICAgICAgICAgIGFkZFdvcmxkVmVydGV4KGZWZXJ0c1swXSk7XG5cbiAgICAgICAgICAgICAgICBjb21taXRWZXJ0aWNlcygpO1xuXG4gICAgICAgICAgICAgICAgbWFrZVV2c0Zvckdlb20oY3VyR2VvbSwgKHB0LCB2ZXJ0SW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIDEgLSAodmVydEluZGV4ICUgMiksXG4gICAgICAgICAgICAgICAgICAgIDEgLSBNYXRoLmZsb29yKHZlcnRJbmRleCAvIDIpXG4gICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2NlaWxpbmcnOlxuXG4gICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0ZXgodFZlcnRzWzNdKTtcbiAgICAgICAgICAgICAgICBhZGRXb3JsZFZlcnRleCh0VmVydHNbMV0pO1xuICAgICAgICAgICAgICAgIGFkZFdvcmxkVmVydGV4KGZWZXJ0c1sxXSk7XG4gICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0ZXgoZlZlcnRzWzNdKTtcblxuICAgICAgICAgICAgICAgIGNvbW1pdFZlcnRpY2VzKCk7XG5cbiAgICAgICAgICAgICAgICBtYWtlVXZzRm9yR2VvbShjdXJHZW9tLCAocHQsIHZlcnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdmVydEluZGV4ICUgMixcbiAgICAgICAgICAgICAgICAgICAgMSAtIE1hdGguZmxvb3IodmVydEluZGV4IC8gMilcbiAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnc2lkZXMnOlxuXG4gICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0ZXgodFZlcnRzWzJdKTtcbiAgICAgICAgICAgICAgICBhZGRXb3JsZFZlcnRleCh0VmVydHNbM10pO1xuICAgICAgICAgICAgICAgIGFkZFdvcmxkVmVydGV4KGZWZXJ0c1swXSk7XG4gICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0ZXgoZlZlcnRzWzFdKTtcblxuICAgICAgICAgICAgICAgIGFkZFdvcmxkVmVydGV4KGZWZXJ0c1syXSk7XG4gICAgICAgICAgICAgICAgYWRkV29ybGRWZXJ0ZXgoZlZlcnRzWzNdKTtcbiAgICAgICAgICAgICAgICBhZGRXb3JsZFZlcnRleCh0VmVydHNbMF0pO1xuICAgICAgICAgICAgICAgIGFkZFdvcmxkVmVydGV4KHRWZXJ0c1sxXSk7XG5cbiAgICAgICAgICAgICAgICBjb21taXRWZXJ0aWNlcygpO1xuXG4gICAgICAgICAgICAgICAgbWFrZVV2c0Zvckdlb20oY3VyR2VvbSwgKHB0LCB2ZXJ0SW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHV2ID0gW107XG4gICAgICAgICAgICAgICAgICB1dlswXSA9IE1hdGguZmxvb3IodmVydEluZGV4IC8gMik7XG4gICAgICAgICAgICAgICAgICB1dlsxXSA9IHZlcnRJbmRleCAlIDI7XG4gICAgICAgICAgICAgICAgICBpZiAodmVydEluZGV4IDwgNCkgeyB1dlswXSA9IDEgLSB1dlswXTsgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHV2O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5pc2hHZW9tKGN1ckdlb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIiA9PT0gUkUtRVZBTFVBVElPTiBDT01QTEVURSFcIik7XG4gICAgICBidWlsZGluZ1NlbGYuZGlydHkgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU2NlbmUgKGxhc3RTY2VuZSkge1xuICBpZiAobGFzdFNjZW5lICYmIGxhc3RTY2VuZS5zeXN0ZW1zLmJ1aWxkaW5nKSB7IGxhc3RTY2VuZS5zeXN0ZW1zLmJ1aWxkaW5nLnJlZXhhbWluZUJ1aWxkaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIHBvc2l0aW9uV2F0Y2ggKGUpIHtcbiAgaWYgKGUuZGV0YWlsLm5hbWUgPT09ICdwb3NpdGlvbicpIHsgdXBkYXRlU2NlbmUoZS5kZXRhaWwudGFyZ2V0LnNjZW5lRWwpOyB9XG59XG5cbmZ1bmN0aW9uIG5vZGVTY2VuZUluaXQgKCkge1xuICB0aGlzLmxhc3RTY2VuZSA9IHRoaXMuZWwuc2NlbmVFbDtcbiAgdXBkYXRlU2NlbmUodGhpcy5sYXN0U2NlbmUpO1xuICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvbmVudGNoYW5nZWQnLCBwb3NpdGlvbldhdGNoKTtcbn1cbmZ1bmN0aW9uIG5vZGVTY2VuZVVwZGF0ZSAoKSB7XG4gIHVwZGF0ZVNjZW5lKHRoaXMubGFzdFNjZW5lKTtcbn1cbmZ1bmN0aW9uIG5vZGVTY2VuZVJlbW92ZSAoKSB7XG4gIHVwZGF0ZVNjZW5lKHRoaXMubGFzdFNjZW5lKTtcbiAgdGhpcy5sYXN0U2NlbmUgPSBudWxsO1xuICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbXBvbmVudGNoYW5nZWQnLCBwb3NpdGlvbldhdGNoKTtcbn1cblxuY29uc3QgcmVmcmVzaFNjZW5lQ29uZmlnID0ge1xuICBpbml0OiBub2RlU2NlbmVJbml0LFxuICB1cGRhdGU6IG5vZGVTY2VuZVVwZGF0ZSxcbiAgcmVtb3ZlOiBub2RlU2NlbmVSZW1vdmVcbn07XG5cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgncm9vbScsIE9iamVjdC5hc3NpZ24oe1xuXG4gIHNjaGVtYToge1xuICAgIG91dHNpZGU6IHsgdHlwZTogJ2Jvb2xlYW4nIH0sXG4gICAgaGVpZ2h0OiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAyLjQgfSxcbiAgICB3aWR0aDogeyB0eXBlOiAnbnVtYmVyJyB9LFxuICAgIGxlbmd0aDogeyB0eXBlOiAnbnVtYmVyJyB9XG4gIH1cblxufSwgcmVmcmVzaFNjZW5lQ29uZmlnKSk7XG5cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnd2FsbCcsIE9iamVjdC5hc3NpZ24oe1xuXG4gIHNjaGVtYToge1xuICAgIGhlaWdodDogeyB0eXBlOiAnbnVtYmVyJyB9XG4gIH1cblxufSwgcmVmcmVzaFNjZW5lQ29uZmlnKSk7XG5cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnZmxvb3InLCByZWZyZXNoU2NlbmVDb25maWcpO1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdjZWlsaW5nJywgcmVmcmVzaFNjZW5lQ29uZmlnKTtcblxuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdkb29yaG9sZScsIHJlZnJlc2hTY2VuZUNvbmZpZyk7XG5cbkFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnZG9vcmxpbmsnLCBPYmplY3QuYXNzaWduKHtcblxuICBzY2hlbWE6IHtcbiAgICBmcm9tOiB7IHR5cGU6ICdzZWxlY3RvcicgfSxcbiAgICB0bzogeyB0eXBlOiAnc2VsZWN0b3InIH0sXG4gICAgaGVpZ2h0OiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAyLjAgfSxcbiAgICB3aWR0aDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMC44IH1cbiAgfVxuXG59LCByZWZyZXNoU2NlbmVDb25maWcpKTtcblxuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdzaWRlcycsIHJlZnJlc2hTY2VuZUNvbmZpZyk7XG5cbi8vIGNvdWxkIHByb2JhYmx5IGF1dG9tYXRlIHRoaXMgcmF0aGVyIHRoYW4gaGFyZC1jb2RpbmcgaXQsIGJ1dCB0aGlzJ2xsIGRvIGZvciBub3c6XG5cbkFGUkFNRS5yZWdpc3RlclByaW1pdGl2ZSgncnctcm9vbScsIHtcbiAgZGVmYXVsdENvbXBvbmVudHM6IHsgcm9vbToge30gfSxcbiAgbWFwcGluZ3M6IHtcbiAgICBvdXRzaWRlOiAncm9vbS5vdXRzaWRlJyxcbiAgICBoZWlnaHQ6ICdyb29tLmhlaWdodCcsXG4gICAgd2lkdGg6ICdyb29tLndpZHRoJyxcbiAgICBsZW5ndGg6ICdyb29tLmxlbmd0aCdcbiAgfVxufSk7XG5cbkFGUkFNRS5yZWdpc3RlclByaW1pdGl2ZSgncnctd2FsbCcsIHtcbiAgZGVmYXVsdENvbXBvbmVudHM6IHsgd2FsbDoge30gfSxcbiAgbWFwcGluZ3M6IHtcbiAgICBoZWlnaHQ6ICd3YWxsLmhlaWdodCdcbiAgfVxufSk7XG5cbkFGUkFNRS5yZWdpc3RlclByaW1pdGl2ZSgncnctZmxvb3InLCB7XG4gIGRlZmF1bHRDb21wb25lbnRzOiB7IGZsb29yOiB7fSB9LFxuICBtYXBwaW5nczoge31cbn0pO1xuXG5BRlJBTUUucmVnaXN0ZXJQcmltaXRpdmUoJ3J3LWNlaWxpbmcnLCB7XG4gIGRlZmF1bHRDb21wb25lbnRzOiB7IGNlaWxpbmc6IHt9IH0sXG4gIG1hcHBpbmdzOiB7fVxufSk7XG5cbkFGUkFNRS5yZWdpc3RlclByaW1pdGl2ZSgncnctZG9vcmhvbGUnLCB7XG4gIGRlZmF1bHRDb21wb25lbnRzOiB7IGRvb3Job2xlOiB7fSB9LFxuICBtYXBwaW5nczoge31cbn0pO1xuXG5BRlJBTUUucmVnaXN0ZXJQcmltaXRpdmUoJ3J3LWRvb3JsaW5rJywge1xuICBkZWZhdWx0Q29tcG9uZW50czogeyBkb29ybGluazoge30gfSxcbiAgbWFwcGluZ3M6IHtcbiAgICBmcm9tOiAnZG9vcmxpbmsuZnJvbScsXG4gICAgdG86ICdkb29ybGluay50bycsXG4gICAgaGVpZ2h0OiAnZG9vcmxpbmsuaGVpZ2h0JyxcbiAgICB3aWR0aDogJ2Rvb3JsaW5rLndpZHRoJ1xuICB9XG59KTtcblxuQUZSQU1FLnJlZ2lzdGVyUHJpbWl0aXZlKCdydy1zaWRlcycsIHtcbiAgZGVmYXVsdENvbXBvbmVudHM6IHsgc2lkZXM6IHt9IH0sXG4gIG1hcHBpbmdzOiB7fVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"]();
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});