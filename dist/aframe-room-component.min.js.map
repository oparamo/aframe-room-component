{"version":3,"file":"aframe-room-component.min.js","mappings":"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","sources":["webpack://aframe-room-component/webpack/universalModuleDefinition","webpack://aframe-room-component/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","'use strict';\n\nAFRAME.registerSystem('building', {\n\n  reexamineBuilding: function () {\n    // console.log(\" = REEVALUATION REQUESTED...\");\n\n    const buildingSelf = this;\n    const HAIR = 0.0001;\n\n    /*\n\n    https://github.com/oparamo/aframe-room-component\n    v0.5.0\n\n    OPTIMIZATION:\n\n    currently, the entire building is getting re-generated from scratch any time anything in it changes.\n    obviously this is wasteful, but:\n    - this library isn't particularly likely to be used in a context where these properties will be changing at runtime (at least outside of debugging)\n    - right now I am more concerned with getting it out the door than making it perfect anyway\n\n    PLANNED FEATURES TO COME (in order):\n    - greater control over UV generation\n    - automatic collision assignment\n    - doors lifted above the ground (i.e. windows)\n    - accept a shape to be extruded around a doorhole to make a doorframe (& around a floor to make a baseboard)\n\n    KNOWN ISSUES (with no obvious solution that would preserve ease of use):\n    - floor/ceiling triangulation is not controllable (and therefore varying wall verticality is nearly useless unless slope is consistent)\n    - doorhole parenting is always level to the horizon even on slope-floored walls\n    - the setTimeout thing results in a one-frame flash of invisible walls: is it worth it? (is there a smarter thing to listen for, maybe?)\n\n    ISSUES THAT COULD THEORETICALLY BE FIXED BUT DON'T SEEM WORTH THE TROUBLE:\n    - walls are internally rearranged to always wind CW, which means wall parenting will point towards the \"previous\" wall if you entered them in CCW order\n\n    */\n\n    function flipGeom (geom) {\n      const indexCopy = geom.index;\n      for (let curFaceIndex = 0; curFaceIndex < indexCopy.count / 3; curFaceIndex++) {\n        const bucket = indexCopy[curFaceIndex * 3 + 2];\n        indexCopy[curFaceIndex * 3 + 2] = indexCopy[curFaceIndex * 3 + 1];\n        indexCopy[curFaceIndex * 3 + 1] = bucket;\n      }\n      geom.setIndex(indexCopy);\n    }\n\n    function makeUvsForGeom (geom, callback) {\n      const allUVs = [];\n      for (let faceVertIndex = 0; faceVertIndex < geom.index.array.length; faceVertIndex++) {\n        const vertexIndex = geom.index.array[faceVertIndex];\n        const vertex = new THREE.Vector3(\n          geom.attributes.position.getX(vertexIndex),\n          geom.attributes.position.getY(vertexIndex),\n          geom.attributes.position.getZ(vertexIndex)\n        );\n        const uv = callback(vertex, faceVertIndex % 3);\n        allUVs[vertexIndex * 2 + 0] = uv[0];\n        allUVs[vertexIndex * 2 + 1] = uv[1];\n      }\n      geom.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(allUVs), 2));\n      geom.uvsNeedUpdate = true;\n    }\n    function makePlaneUvs (geom, uKey, vKey, uMult, vMult) {\n      makeUvsForGeom(geom, (pt) => {\n        return [\n          pt[uKey] * uMult,\n          pt[vKey] * vMult\n        ];\n      });\n    }\n\n    function finishGeom (geom) {\n      geom.computeVertexNormals();\n      // are these necessary?\n      geom.computeBoundingBox();\n      geom.computeBoundingSphere();\n    }\n\n    function getUnsortedRoomWallArray (roomEl) {\n      const walls = [];\n      for (let roomChildNodeIndex = 0; roomChildNodeIndex < roomEl.children.length; roomChildNodeIndex++) {\n        const roomChildNode = roomEl.children[roomChildNodeIndex];\n        if (roomChildNode.components.wall) { walls.push(roomChildNode); }\n      }\n      return walls;\n    }\n\n    function getRoomWallArray (roomEl) {\n      // the results of this not being saved anywhere is super wasteful,\n      // but, see above; not worth worrying about yet\n\n      const isOutside = roomEl.components.room.data.outside;\n\n      const walls = getUnsortedRoomWallArray(roomEl);\n\n      let cwSum = 0;\n      for (let wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n        const curWallNode = walls[wallIndex];\n        const nextWallNode = walls[(wallIndex + 1) % walls.length];\n        const curWallPos = curWallNode.components.position.data;\n        const nextWallPos = nextWallNode.components.position.data;\n\n        cwSum += (nextWallPos.x - curWallPos.x) * (nextWallPos.z + curWallPos.z);\n      }\n\n      let shouldReverse = false;\n      if (cwSum > 0) { shouldReverse = !shouldReverse; }\n      if (isOutside) { shouldReverse = !shouldReverse; }\n      if (shouldReverse) { walls.reverse(); }\n\n      return walls;\n    }\n    function getNextWallEl (wallEl) {\n      const wallList = getRoomWallArray(wallEl.parentNode);\n      const curWallIndex = wallList.indexOf(wallEl);\n      return wallList[(curWallIndex + 1) % wallList.length];\n    }\n\n    const worldWallPos = new THREE.Vector3();\n    const worldNextPos = new THREE.Vector3();\n    const worldLinkPos = new THREE.Vector3();\n    function moveForLink (doorholeEl, doorlinkEl) {\n      const holeWallEl = doorholeEl.parentNode;\n      const nextWallEl = getNextWallEl(holeWallEl);\n      if (!nextWallEl) { return; }\n\n      holeWallEl.object3D.getWorldPosition(worldWallPos);\n      nextWallEl.object3D.getWorldPosition(worldNextPos);\n      doorlinkEl.object3D.getWorldPosition(worldLinkPos);\n\n      const linkGapX = worldLinkPos.x - worldWallPos.x;\n      const linkGapZ = worldLinkPos.z - worldWallPos.z;\n\n      const wallGapX = worldNextPos.x - worldWallPos.x;\n      const wallGapZ = worldNextPos.z - worldWallPos.z;\n      const wallAng = Math.atan2(wallGapZ, wallGapX);\n      const wallLength = Math.sqrt(wallGapX * wallGapX + wallGapZ * wallGapZ);\n\n      let localLinkX = linkGapX * Math.cos(-wallAng) - linkGapZ * Math.sin(-wallAng);\n      // var localLinkZ = linkGapX*Math.sin(-wallAng) + linkGapZ*Math.cos(-wallAng);\n\n      const doorHalf = doorlinkEl.components.doorlink.data.width / 2;\n      localLinkX = Math.max(localLinkX, doorHalf + HAIR);\n      localLinkX = Math.min(localLinkX, wallLength - doorHalf - HAIR);\n\n      doorholeEl.setAttribute('position', { x: localLinkX, y: 0, z: 0 });\n      doorholeEl.object3D.updateMatrixWorld();\n    }\n\n    function getHoleLink (doorholeEl) {\n      const doorlinks = buildingSelf.el.querySelectorAll('[doorlink]');\n      for (let curLinkIndex = 0; curLinkIndex < doorlinks.length; curLinkIndex++) {\n        const curLink = doorlinks[curLinkIndex];\n        if (curLink.components.doorlink.data.from == doorholeEl) { return curLink; }\n        if (curLink.components.doorlink.data.to == doorholeEl) { return curLink; }\n      }\n    }\n\n    function getWallHeight (wallEl) {\n      if (wallEl.components.wall.data.height) { return wallEl.components.wall.data.height; }\n      return wallEl.parentNode.components.room.data.height;\n    }\n\n    if (buildingSelf.dirty) { return; }\n    buildingSelf.dirty = true;\n    setTimeout(() => {\n      // console.log(\" == STARTING RE-EVALUATION...\");\n\n      // silly but necessary because of threeJS weirdness\n      buildingSelf.el.object3D.updateMatrixWorld();\n\n      // lay out walls' angles:\n\n      for (var sceneChildNodeIndex = 0; sceneChildNodeIndex < buildingSelf.el.children.length; sceneChildNodeIndex++) {\n        var sceneChildNode = buildingSelf.el.children[sceneChildNodeIndex];\n        if (sceneChildNode.components && sceneChildNode.components.room) {\n          const w = sceneChildNode.components.room.data.width;\n          const l = sceneChildNode.components.room.data.length;\n          if (w || l) {\n            if (w && l) {\n              const rawWalls = getUnsortedRoomWallArray(sceneChildNode);\n              if (rawWalls.length >= 4) {\n                if (rawWalls.length > 4) { console.error('rooms with WIDTH and LENGTH should only have four walls!'); }\n                rawWalls[0].setAttribute('position', { x: 0, y: 0, z: 0 });\n                rawWalls[1].setAttribute('position', { x: w, y: 0, z: 0 });\n                rawWalls[2].setAttribute('position', { x: w, y: 0, z: l });\n                rawWalls[3].setAttribute('position', { x: 0, y: 0, z: l });\n              } else {\n                console.error('rooms with WIDTH and LENGTH must have four walls!');\n              }\n            } else {\n              console.error('rooms with WIDTH must also have LENGTH (and vice versa)');\n            }\n          }\n\n          var walls = getRoomWallArray(sceneChildNode);\n          if (walls.length > 2) {\n            for (var wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n              var curWallNode = walls[wallIndex];\n              var nextWallNode = walls[(wallIndex + 1) % walls.length];\n\n              var wallGapX = nextWallNode.components.position.data.x - curWallNode.components.position.data.x;\n              var wallGapZ = nextWallNode.components.position.data.z - curWallNode.components.position.data.z;\n              var wallAng = Math.atan2(wallGapZ, wallGapX);\n\n              curWallNode.setAttribute('rotation', { x: 0, y: -wallAng / Math.PI * 180, z: 0 });\n              curWallNode.object3D.updateMatrixWorld();\n            }\n          }\n        }\n      }\n\n      // position the door holes:\n\n      const doorlinks = buildingSelf.el.querySelectorAll('[doorlink]');\n      for (var curDoorlinkElIndex = 0; curDoorlinkElIndex < doorlinks.length; curDoorlinkElIndex++) {\n        var curDoorlinkEl = doorlinks[curDoorlinkElIndex];\n        var curDoorlink = curDoorlinkEl.components.doorlink;\n        if (!curDoorlink) { return; }// still setting up, try again later\n\n        moveForLink(curDoorlink.data.from, curDoorlink.el);\n        moveForLink(curDoorlink.data.to, curDoorlink.el);\n      }\n\n      // generate the walls' geometry:\n\n      for (var sceneChildNodeIndex = 0; sceneChildNodeIndex < buildingSelf.el.children.length; sceneChildNodeIndex++) {\n        var sceneChildNode = buildingSelf.el.children[sceneChildNodeIndex];\n        if (sceneChildNode.components && sceneChildNode.components.room) {\n          const isOutside = sceneChildNode.components.room.data.outside;\n          var walls = getRoomWallArray(sceneChildNode);\n\n          if (walls.length > 2) {\n            for (var wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n              var curWallNode = walls[wallIndex];\n              var nextWallNode = walls[(wallIndex + 1) % walls.length];\n\n              var wallGapX = nextWallNode.components.position.data.x - curWallNode.components.position.data.x;\n              var wallGapZ = nextWallNode.components.position.data.z - curWallNode.components.position.data.z;\n              const wallLength = Math.sqrt(wallGapX * wallGapX + wallGapZ * wallGapZ);\n              var wallAng = Math.atan2(wallGapZ, wallGapX);\n\n              const wallGapY = nextWallNode.components.position.data.y - curWallNode.components.position.data.y;\n              const heightGap = getWallHeight(nextWallNode) - getWallHeight(curWallNode);\n\n              const orderedHoles = [];\n              for (let wallChildNodeIndex = 0; wallChildNodeIndex < curWallNode.children.length; wallChildNodeIndex++) {\n                const wallChildNode = curWallNode.children[wallChildNodeIndex];\n                if (wallChildNode.components && wallChildNode.components.doorhole) {\n                  orderedHoles.push(wallChildNode);\n                }\n              }\n              orderedHoles.sort((a, b) => {\n                return a.components.position.data.x - b.components.position.data.x;\n              });\n\n              const wallShape = new THREE.Shape();\n              wallShape.moveTo(\n                0,\n                getWallHeight(curWallNode)\n              );\n              wallShape.lineTo(\n                0,\n                0\n              );\n\n              for (let holeIndex = 0; holeIndex < orderedHoles.length; holeIndex++) {\n                var holeEl = orderedHoles[holeIndex];\n                if (!holeEl.myVerts) { holeEl.myVerts = []; }\n                holeEl.myVerts.length = 0;\n\n                const linkEl = getHoleLink(orderedHoles[holeIndex]);\n                if (!linkEl) { continue; }\n\n                const holeInfo = holeEl.components;\n                const linkInfo = linkEl.components;\n\n                for (let holeSide = -1; holeSide <= 1; holeSide += 2) {\n                  var ptX = holeInfo.position.data.x + linkInfo.doorlink.data.width / 2 * holeSide;\n                  const floorY = (ptX / wallLength) * wallGapY;\n                  let topY = floorY + linkInfo.doorlink.data.height;\n\n                  const curCeil = getWallHeight(curWallNode) + (ptX / wallLength) * heightGap;\n                  const maxTopY = floorY + curCeil - HAIR;// will always be a seam, but, I'm not bothering to rewrite just for that\n                  if (topY > maxTopY) { topY = maxTopY; }\n\n                  function addWorldVert (ptY) {\n                    const tempPos = new THREE.Vector3(ptX, ptY, 0);\n                    curWallNode.object3D.localToWorld(tempPos);\n                    holeEl.myVerts.push(tempPos);\n                  }\n                  addWorldVert(floorY);\n                  addWorldVert(topY);\n\n                  if (holeSide < 0) {\n                    wallShape.lineTo(ptX, floorY);\n                    wallShape.lineTo(ptX, topY);\n                  } else {\n                    wallShape.lineTo(ptX, topY);\n                    wallShape.lineTo(ptX, floorY);\n                  }\n                }\n              }\n\n              wallShape.lineTo(\n                wallLength,\n                nextWallNode.components.position.data.y - curWallNode.components.position.data.y\n              );\n              wallShape.lineTo(\n                wallLength,\n                (nextWallNode.components.position.data.y - curWallNode.components.position.data.y) + getWallHeight(nextWallNode)\n              );\n\n              const wallGeom = new THREE.ShapeGeometry(wallShape);\n              makePlaneUvs(wallGeom, 'x', 'y', 1, 1);\n              finishGeom(wallGeom);\n              var myMat = curWallNode.components.material ? curWallNode.components.material.material : curWallNode.parentNode.components.material.material;\n              if (curWallNode.myMesh) {\n                curWallNode.myMesh.geometry = wallGeom;\n                curWallNode.myMesh.material = myMat;\n              } else {\n                curWallNode.myMesh = new THREE.Mesh(wallGeom, myMat);\n                curWallNode.setObject3D('wallMesh', curWallNode.myMesh);\n              }\n            }\n\n            const caps = [];\n            for (let roomChildNodeIndex = 0; roomChildNodeIndex < sceneChildNode.children.length; roomChildNodeIndex++) {\n              const roomChildNode = sceneChildNode.children[roomChildNodeIndex];\n              if (roomChildNode.components) {\n                if (roomChildNode.components.floor || roomChildNode.components.ceiling) { caps.push(roomChildNode); }\n              }\n            }\n            for (let curCapNodeIndex = 0; curCapNodeIndex < caps.length; curCapNodeIndex++) {\n              const curCapNode = caps[curCapNodeIndex];\n              const isCeiling = curCapNode.components.ceiling;\n\n              const capShape = new THREE.Shape();\n              for (var wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n                var curWallNode = walls[wallIndex];\n                var ptX = curWallNode.components.position.data.x;\n                const ptZ = curWallNode.components.position.data.z;\n                if (wallIndex) {\n                  capShape.lineTo(ptX, ptZ);\n                } else {\n                  capShape.moveTo(ptX, ptZ);\n                }\n              }\n              const capGeom = new THREE.ShapeGeometry(capShape);\n              for (var wallIndex = 0; wallIndex < walls.length; wallIndex++) {\n                var curWallNode = walls[wallIndex];\n                const curVert = new THREE.Vector3(\n                  capGeom.attributes.position.getX(wallIndex),\n                  capGeom.attributes.position.getY(wallIndex),\n                  capGeom.attributes.position.getZ(wallIndex)\n                );\n                curVert.set(curVert.x, curWallNode.components.position.data.y, curVert.y);\n                if (isCeiling) { curVert.y += getWallHeight(curWallNode); }\n                capGeom.attributes.position.setXYZ(wallIndex, curVert.x, curVert.y, curVert.z);\n              }\n\n              let shouldReverse = false;\n              if (!isCeiling) { shouldReverse = !shouldReverse; }\n              if (isOutside) { shouldReverse = !shouldReverse; }\n              if (shouldReverse) { flipGeom(capGeom); }\n\n              makePlaneUvs(capGeom, 'x', 'z', isCeiling ? 1 : -1, 1);\n              finishGeom(capGeom);\n\n              if (!curCapNode.myMeshes) { curCapNode.myMeshes = []; }\n\n              const typeLabel = isCeiling ? 'ceiling' : 'floor';\n              var myMat = curCapNode.components.material ? curCapNode.components.material.material : curCapNode.parentNode.components.material.material;\n              if (curCapNode.myMeshes[typeLabel]) {\n                curCapNode.myMeshes[typeLabel].geometry = capGeom;\n                curCapNode.myMeshes[typeLabel].material = myMat;\n              } else {\n                curCapNode.myMeshes[typeLabel] = new THREE.Mesh(capGeom, myMat);\n                curCapNode.setObject3D(typeLabel, curCapNode.myMeshes[typeLabel]);\n              }\n            }\n          }\n        }\n      }\n\n      // generate the door tunnels' geometry:\n\n      for (var curDoorlinkElIndex = 0; curDoorlinkElIndex < doorlinks.length; curDoorlinkElIndex++) {\n        var curDoorlinkEl = doorlinks[curDoorlinkElIndex];\n\n        var curDoorlink = curDoorlinkEl.components.doorlink;\n        if (!curDoorlink.data.from) { continue; }\n        if (!curDoorlink.data.to) { continue; }\n        if (!curDoorlink.data.from.myVerts) { return; }\n        if (!curDoorlink.data.to.myVerts) { return; }\n\n        for (let doorLinkChildIndex = 0; doorLinkChildIndex < curDoorlinkEl.children.length; doorLinkChildIndex++) {\n          var doorLinkChild = curDoorlinkEl.children[doorLinkChildIndex];\n          if (!doorLinkChild.components) { continue; }\n\n          const types = ['sides', 'floor', 'ceiling'];\n          for (let curTypeIndex = 0; curTypeIndex < types.length; curTypeIndex++) {\n            const curType = types[curTypeIndex];\n\n            if (!doorLinkChild.components[curType]) { continue; }\n\n            var myMat = doorLinkChild.components.material ? doorLinkChild.components.material.material : doorLinkChild.parentNode.components.material.material;\n\n            if (!doorLinkChild.myGeoms) { doorLinkChild.myGeoms = []; }\n            if (!doorLinkChild.myGeoms[curType]) {\n              var curGeom = new THREE.BufferGeometry();\n              doorLinkChild.myGeoms[curType] = curGeom;\n              const myMesh = new THREE.Mesh(\n                curGeom,\n                myMat\n              );\n              curGeom.meshRef = myMesh;\n              doorLinkChild.setObject3D(curType, myMesh);\n              const indexArray = [];\n              indexArray.push(0, 1, 2, 1, 3, 2);\n              if (curType == 'sides') { indexArray.push(4, 5, 6, 5, 7, 6); }\n              curGeom.setIndex(indexArray);\n            }\n\n            var curGeom = doorLinkChild.myGeoms[curType];\n            curGeom.meshRef.material = myMat;\n            var positionArray = [];\n            function addWorldVertex (pt) {\n              const localPt = pt.clone();\n              doorLinkChild.object3D.worldToLocal(localPt);\n              positionArray.push(localPt.x, localPt.y, localPt.z);\n            }\n            function commitVertices () {\n              curGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positionArray), 3));\n            }\n            const fVerts = curDoorlink.data.from.myVerts;\n            const tVerts = curDoorlink.data.to.myVerts;\n            switch (curType) {\n              case 'floor':\n\n                addWorldVertex(tVerts[0]);\n                addWorldVertex(tVerts[2]);\n                addWorldVertex(fVerts[2]);\n                addWorldVertex(fVerts[0]);\n\n                commitVertices();\n\n                makeUvsForGeom(curGeom, (pt, vertIndex) => {\n                  return [\n                    1 - (vertIndex % 2),\n                    1 - Math.floor(vertIndex / 2)\n                  ];\n                });\n\n                break;\n              case 'ceiling':\n\n                addWorldVertex(tVerts[3]);\n                addWorldVertex(tVerts[1]);\n                addWorldVertex(fVerts[1]);\n                addWorldVertex(fVerts[3]);\n\n                commitVertices();\n\n                makeUvsForGeom(curGeom, (pt, vertIndex) => {\n                  return [\n                    vertIndex % 2,\n                    1 - Math.floor(vertIndex / 2)\n                  ];\n                });\n\n                break;\n              case 'sides':\n\n                addWorldVertex(tVerts[2]);\n                addWorldVertex(tVerts[3]);\n                addWorldVertex(fVerts[0]);\n                addWorldVertex(fVerts[1]);\n\n                addWorldVertex(fVerts[2]);\n                addWorldVertex(fVerts[3]);\n                addWorldVertex(tVerts[0]);\n                addWorldVertex(tVerts[1]);\n\n                commitVertices();\n\n                makeUvsForGeom(curGeom, (pt, vertIndex) => {\n                  const uv = [];\n                  uv[0] = Math.floor(vertIndex / 2);\n                  uv[1] = vertIndex % 2;\n                  if (vertIndex < 4) { uv[0] = 1 - uv[0]; }\n                  return uv;\n                });\n\n                break;\n            }\n            finishGeom(curGeom);\n          }\n        }\n      }\n\n      // console.log(\" === RE-EVALUATION COMPLETE!\");\n      buildingSelf.dirty = false;\n    });\n  }\n\n});\n\nfunction updateScene (lastScene) {\n  if (lastScene && lastScene.systems.building) { lastScene.systems.building.reexamineBuilding(); }\n}\nfunction positionWatch (e) {\n  if (e.detail.name == 'position') { updateScene(e.detail.target.sceneEl); }\n}\n\nfunction nodeSceneInit () {\n  this.lastScene = this.el.sceneEl;\n  updateScene(this.lastScene);\n  this.el.addEventListener('componentchanged', positionWatch);\n}\nfunction nodeSceneUpdate () {\n  updateScene(this.lastScene);\n}\nfunction nodeSceneRemove () {\n  updateScene(this.lastScene);\n  this.lastScene = null;\n  this.el.removeEventListener('componentchanged', positionWatch);\n}\n\nconst refreshSceneConfig = {\n  init: nodeSceneInit,\n  update: nodeSceneUpdate,\n  remove: nodeSceneRemove\n};\n\nAFRAME.registerComponent('room', Object.assign({\n\n  schema: {\n    outside: { type: 'boolean' },\n    height: { type: 'number', default: 2.4 },\n    width: { type: 'number' },\n    length: { type: 'number' }\n  }\n\n}, refreshSceneConfig));\n\nAFRAME.registerComponent('wall', Object.assign({\n\n  schema: {\n    height: { type: 'number' }\n  }\n\n}, refreshSceneConfig));\n\nAFRAME.registerComponent('floor', refreshSceneConfig);\nAFRAME.registerComponent('ceiling', refreshSceneConfig);\n\nAFRAME.registerComponent('doorhole', refreshSceneConfig);\n\nAFRAME.registerComponent('doorlink', Object.assign({\n\n  schema: {\n    from: { type: 'selector' },\n    to: { type: 'selector' },\n    height: { type: 'number', default: 2.0 },\n    width: { type: 'number', default: 0.8 }\n  }\n\n}, refreshSceneConfig));\n\nAFRAME.registerComponent('sides', refreshSceneConfig);\n\n// could probably automate this rather than hard-coding it, but this'll do for now:\n\nAFRAME.registerPrimitive('rw-room', {\n  defaultComponents: { room: {} },\n  mappings: {\n    outside: 'room.outside',\n    height: 'room.height',\n    width: 'room.width',\n    length: 'room.length'\n  }\n});\n\nAFRAME.registerPrimitive('rw-wall', {\n  defaultComponents: { wall: {} },\n  mappings: {\n    height: 'wall.height'\n  }\n});\n\nAFRAME.registerPrimitive('rw-floor', {\n  defaultComponents: { floor: {} },\n  mappings: {}\n});\n\nAFRAME.registerPrimitive('rw-ceiling', {\n  defaultComponents: { ceiling: {} },\n  mappings: {}\n});\n\nAFRAME.registerPrimitive('rw-doorhole', {\n  defaultComponents: { doorhole: {} },\n  mappings: {}\n});\n\nAFRAME.registerPrimitive('rw-doorlink', {\n  defaultComponents: { doorlink: {} },\n  mappings: {\n    from: 'doorlink.from',\n    to: 'doorlink.to',\n    height: 'doorlink.height',\n    width: 'doorlink.width'\n  }\n});\n\nAFRAME.registerPrimitive('rw-sides', {\n  defaultComponents: { sides: {} },\n  mappings: {}\n});\n"],"names":["root","factory","exports","module","define","amd","a","i","self","updateScene","lastScene","systems","building","reexamineBuilding","positionWatch","e","detail","name","target","sceneEl","AFRAME","registerSystem","buildingSelf","this","HAIR","flipGeom","geom","indexCopy","index","curFaceIndex","count","bucket","setIndex","makeUvsForGeom","callback","allUVs","faceVertIndex","array","length","vertexIndex","uv","THREE","Vector3","attributes","position","getX","getY","getZ","setAttribute","BufferAttribute","Float32Array","uvsNeedUpdate","makePlaneUvs","uKey","vKey","uMult","vMult","pt","finishGeom","computeVertexNormals","computeBoundingBox","computeBoundingSphere","getUnsortedRoomWallArray","roomEl","walls","roomChildNodeIndex","children","roomChildNode","components","wall","push","getRoomWallArray","isOutside","room","data","outside","cwSum","wallIndex","curWallNode","nextWallNode","curWallPos","nextWallPos","x","z","shouldReverse","reverse","worldWallPos","worldNextPos","worldLinkPos","moveForLink","doorholeEl","doorlinkEl","wallEl","wallList","curWallIndex","holeWallEl","parentNode","nextWallEl","indexOf","object3D","getWorldPosition","linkGapX","linkGapZ","wallGapX","wallGapZ","wallAng","Math","atan2","wallLength","sqrt","localLinkX","cos","sin","doorHalf","doorlink","width","max","min","y","updateMatrixWorld","getHoleLink","doorlinks","el","querySelectorAll","curLinkIndex","curLink","from","to","getWallHeight","height","dirty","setTimeout","sceneChildNodeIndex","sceneChildNode","w","l","rawWalls","console","error","PI","curDoorlinkElIndex","curDoorlinkEl","curDoorlink","wallGapY","heightGap","orderedHoles","wallChildNodeIndex","wallChildNode","doorhole","sort","b","wallShape","Shape","moveTo","lineTo","holeIndex","holeEl","myVerts","linkEl","holeInfo","linkInfo","floorY","ptX","holeSide","topY","maxTopY","addWorldVert","ptY","tempPos","localToWorld","wallGeom","ShapeGeometry","myMat","material","myMesh","geometry","Mesh","setObject3D","caps","floor","ceiling","curCapNodeIndex","curCapNode","isCeiling","capShape","ptZ","capGeom","curVert","set","setXYZ","myMeshes","typeLabel","doorLinkChildIndex","doorLinkChild","types","curType","curTypeIndex","myGeoms","curGeom","BufferGeometry","meshRef","indexArray","addWorldVertex","localPt","clone","worldToLocal","positionArray","commitVertices","fVerts","tVerts","vertIndex","refreshSceneConfig","init","addEventListener","update","remove","removeEventListener","registerComponent","Object","assign","schema","type","default","registerPrimitive","defaultComponents","mappings","sides"],"sourceRoot":""}